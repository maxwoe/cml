/*
 * generated by Xtext 2.16.0
 */
package at.ac.univie.swa.generator

import at.ac.univie.swa.CmlLib
import at.ac.univie.swa.CmlModelUtil
import at.ac.univie.swa.cml.ActionQuery
import at.ac.univie.swa.cml.AdditiveExpression
import at.ac.univie.swa.cml.AndCompoundAction
import at.ac.univie.swa.cml.AndExpression
import at.ac.univie.swa.cml.AssignmentExpression
import at.ac.univie.swa.cml.AtomicAction
import at.ac.univie.swa.cml.Attribute
import at.ac.univie.swa.cml.Block
import at.ac.univie.swa.cml.BooleanLiteral
import at.ac.univie.swa.cml.CastedExpression
import at.ac.univie.swa.cml.Clause
import at.ac.univie.swa.cml.ClauseQuery
import at.ac.univie.swa.cml.ClauseStatus
import at.ac.univie.swa.cml.CmlClass
import at.ac.univie.swa.cml.CmlProgram
import at.ac.univie.swa.cml.CompoundAction
import at.ac.univie.swa.cml.DateTimeLiteral
import at.ac.univie.swa.cml.Deontic
import at.ac.univie.swa.cml.DoWhileStatement
import at.ac.univie.swa.cml.DurationLiteral
import at.ac.univie.swa.cml.EqualityExpression
import at.ac.univie.swa.cml.EventQuery
import at.ac.univie.swa.cml.Expression
import at.ac.univie.swa.cml.FeatureSelection
import at.ac.univie.swa.cml.ForStatement
import at.ac.univie.swa.cml.IfStatement
import at.ac.univie.swa.cml.Import
import at.ac.univie.swa.cml.IntegerLiteral
import at.ac.univie.swa.cml.MultiplicativeExpression
import at.ac.univie.swa.cml.NamedElement
import at.ac.univie.swa.cml.NestedCompoundAction
import at.ac.univie.swa.cml.NestedExpression
import at.ac.univie.swa.cml.Operation
import at.ac.univie.swa.cml.OrCompoundAction
import at.ac.univie.swa.cml.OrExpression
import at.ac.univie.swa.cml.PostfixExpression
import at.ac.univie.swa.cml.RealLiteral
import at.ac.univie.swa.cml.RelationalExpression
import at.ac.univie.swa.cml.ReturnStatement
import at.ac.univie.swa.cml.Statement
import at.ac.univie.swa.cml.StringLiteral
import at.ac.univie.swa.cml.SuperExpression
import at.ac.univie.swa.cml.SwitchStatement
import at.ac.univie.swa.cml.SymbolReference
import at.ac.univie.swa.cml.TemporalConstraint
import at.ac.univie.swa.cml.TemporalPrecedence
import at.ac.univie.swa.cml.ThisExpression
import at.ac.univie.swa.cml.ThrowStatement
import at.ac.univie.swa.cml.Type
import at.ac.univie.swa.cml.UnaryExpression
import at.ac.univie.swa.cml.VariableDeclaration
import at.ac.univie.swa.cml.WhileStatement
import at.ac.univie.swa.cml.XorCompoundAction
import at.ac.univie.swa.typing.CmlTypeConformance
import com.google.inject.Inject
import java.io.InputStream
import java.math.BigDecimal
import java.time.Instant
import java.util.LinkedHashMap
import java.util.LinkedHashSet
import java.util.List
import java.util.Scanner
import java.util.Set
import org.apache.log4j.Logger
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CmlGenerator extends AbstractGenerator2 {

	static final Logger LOG = Logger.getLogger(CmlGenerator)
	int fixedPointDecimals
	boolean fixedPointArithmetic
	boolean safeMath
	boolean pullPayment
	boolean ownable
	@Inject extension CmlModelUtil
	@Inject extension CmlTypeConformance
	Iterable<CmlProgram> allResources
	
	override doGenerate(Resource resource, ResourceSet input, IFileSystemAccess2 fsa, IGeneratorContext context) {
		LOG.info("resource: " + resource)
		
		allResources = input.resources.map(r|r.allContents.toIterable.filter(CmlProgram)).flatten

		copyResource("openzeppelin/Escrow.sol", fsa)
		copyResource("openzeppelin/Ownable.sol", fsa)
		copyResource("openzeppelin/PullPayment.sol", fsa)
		copyResource("openzeppelin/SafeMath.sol", fsa)
		copyResource("openzeppelin/Secondary.sol", fsa)
		copyResource("cml/FPMath.sol", fsa)
		copyResource("cml/DateTime.sol", fsa)
		copyResource("cml/IntLib.sol", fsa)
		copyResource("cml/RealLib.sol", fsa)
		copyResource("cml/ConditionalContract.sol", fsa)
		
		for (p : resource.allContents.toIterable.filter(CmlProgram)) {
			if (!p.contracts.empty) {
				fsa.generateFile("/" + resource.URI.trimFileExtension.segmentsList.last + ".sol", p.compile)
			}
		}
	}

	def copyResource(String resourceName, IFileSystemAccess2 fsa) {
		val url = class.classLoader.getResource(resourceName)
		val inputStream = url.openStream
		try {
			fsa.generateFile("/lib/" + resourceName, inputStream.convertToString)
		} finally {
			inputStream.close()
		}
	}
	
	def static convertToString(InputStream is) {
		val Scanner s = new Scanner(is).useDelimiter("\\A")
		if (s.hasNext()) s.next() else ""
	}

	def deriveInheritance(CmlClass c) {
		var list = newLinkedList
		list.add("ConditionalContract")
		if (ownable)
			list.add("Ownable")
		if (pullPayment)
			list.add("PullPayment")
		list
	}
	
	def initGeneratorSettings() {
		fixedPointDecimals = 2
		fixedPointArithmetic = false
		safeMath = false
		pullPayment = false
		ownable = false
	}
	
	def deriveGeneratorSettings(CmlClass c) {
		initGeneratorSettings
		for (a : c.annotations) {
			val declaration = a.declaration
			switch (declaration.name) {
				case "SafeMath":
					safeMath = true
				case "FixedPointArithmetic": {
					fixedPointArithmetic = true
					if (!a.args.empty) {
						val integerLiteral = a.args.get(0).value
						if (integerLiteral instanceof IntegerLiteral)
							fixedPointDecimals = integerLiteral.value
					}
				}
				case "Ownable":
					ownable = true
				case "PullPayment":
					pullPayment = true
			}
		}
	}
	
	def compile(CmlProgram program) '''
		pragma solidity >=0.4.22 <0.7.0;
		pragma experimental ABIEncoderV2;
		«FOR contract : program.contracts»
			«contract.deriveGeneratorSettings»
			«IF ownable»import "./lib/openzeppelin/Ownable.sol";«ENDIF»
			«IF pullPayment»import "./lib/openzeppelin/PullPayment.sol";«ENDIF»
			«IF safeMath»import "./lib/openzeppelin/SafeMath.sol";«ENDIF»
			«IF fixedPointArithmetic»import "./lib/cml/FPMath.sol";«ENDIF»
			import "./lib/cml/ConditionalContract.sol";
			import "./lib/cml/DateTime.sol";
			import "./lib/cml/IntLib.sol";
			import "./lib/cml/RealLib.sol";
			
			contract «contract.name»«FOR a : contract.deriveInheritance BEFORE " is " SEPARATOR ", "»«a»«ENDFOR» {
			
				«contract.compileEnums»
				«contract.compileStructs»
				«contract.compileEvents»
				«"/*\n * State variables\n */\n"»
				«contract.compileAttributes»
				uint _contractStart;
				
				«"/*\n * Constructor\n */\n"»
				«contract.compileConstructor»
				
				«"/*\n * Functions\n */\n"»
				«contract.compileFunctions»
				«contract.compileEventFunctions»
				«contract.compileStaticFunctions»
				// Fallback function
				function() external payable {}
				
				«contract.compileClauseConstraints»
				«contract.compileClauseFulfilledTime»
				«contract.compileContractObeyed»
			}
		«ENDFOR»
	'''

	def compileClauseConstraints(CmlClass c) '''
		function clauseAllowed(bytes32 _clauseId) internal returns (bool) {
			«FOR clause : c.clauses»
				if (_clauseId == "«clause.name»") {
					«FOR constraint : clause.deriveConstraints»
						require(«constraint.key»«IF !constraint.value.nullOrEmpty», "«constraint.value»"«ENDIF»);
					«ENDFOR»
					return true;
				}
	   		«ENDFOR»		      
			return false;
		}

	'''

	def compileClauseFulfilledTime(CmlClass c) '''
		function clauseFulfilledTime(bytes32 _clauseId) internal returns (uint) {
			uint max = 0;
			«FOR clause : c.clauses»
				if (_clauseId == "«clause.name»" && («clause.action.compoundAction.compile»)) {
					«var actions = clause.action.compoundAction.eAllOfType(AtomicAction).map[operation.name]»
					«FOR a : actions»
						if (max < «callTime(a)») {
							max =  «callTime(a)»;
						}
					«ENDFOR»
					return max;
				}
	   		«ENDFOR»		      
			return max;
		}

	'''
	
	def compileContractObeyed(CmlClass c) '''
		function contractObeyed() internal returns (bool) {
			«FOR clause : c.clauses.filter[clause | clause.action.deontic.equals(Deontic.MUST) && !c.reparationClauses.exists[it === clause.name]]»
				«val tc = clause.constraint.temporal»
«««				TODO: ClauseQuery failed handling
				if («IF !(tc.reference instanceof Expression)»«tc.reference.deriveReferenceCompletionTime» != 0  && «ENDIF»now > «tc.completionTime») {
					require(«clause.action.compoundAction.compile», "CONTRACT BREACHED: Clause «clause.name» not fulfilled");
				}
	   		«ENDFOR»		      
			return true;
		}

	'''
	
	def reparationClauses(CmlClass c) {
		c.clauses.filter [it.constraint.temporal.reference instanceof ClauseQuery &&
				(it.constraint.temporal.reference as ClauseQuery).status.equals(ClauseStatus.FAILED)
		].map[(it.constraint.temporal.reference as ClauseQuery).clause.name]
	}
	
	def completionTime(TemporalConstraint tc) {
		if(tc.precedence.equals(TemporalPrecedence.AFTER))
			"DateTime.addDuration(" + tc.reference.deriveReferenceCompletionTime + ", " + tc.timeframe.window.compile + ")"
		else if (tc.precedence.equals(TemporalPrecedence.BEFORE))
			tc.reference.deriveReferenceCompletionTime
	}
	
	def String deriveReferenceCompletionTime(EObject reference) {
		if(reference instanceof Expression)
			reference.compile
		else if(reference instanceof ClauseQuery)
			clauseFulfilledTime(reference.clause)
		else if(reference instanceof EventQuery)
			callTime(reference.event.name.concat("Event"))
		else if(reference instanceof ActionQuery)
			callTime(reference.action.name)
	}
		
	def temporalCheckReason(TemporalConstraint tc) {
		if (tc.precedence.equals(TemporalPrecedence.AFTER) && !tc.hasTimeFrame)
			"Function called too early"
		else if (tc.precedence.equals(TemporalPrecedence.BEFORE) && !tc.hasTimeFrame)
			"Function called too late"
		else "Function not called within expected timeframe"
	}
	
	def temporalCheck(TemporalPrecedence precedence, String time, String duration, boolean within) {
		"only" + precedence.literal.toFirstUpper + "(" + time + ", " + duration + ", " + within.booleanValue + ")"
	}
	
	def conditionalCheck(String condition) {
		condition
	}
	
	def callerCheck(String account) {
		"onlyBy(" + account + ".id" + ")"
	}
	
	def callSuccess(String signature) {
		"callSuccess("+ signature.selector +")"
	}
	
	def callTime(String signature) {
		"callTime("+ signature.selector +")"
	}
	
	def callCaller(String signature) {
		"callCaller("+ signature.selector +")"
	}
	
	def selector(String signature) {
		"this."+ signature + ".selector"
	}
	
	def clauseFulfilledTime(Clause clause) {
		"clauseFulfilledTime(\"" + clause.name + "\")"
	}
	
	def hasTimeFrame(TemporalConstraint tc) {
		tc.timeframe !== null
	}
			
	def deriveConstraints(Clause c) {
		var constraints = newArrayList
		val party = c.actor.party
		val tc = c.constraint.temporal
		val gc = c.constraint.general
		if (party.name != "anyone")
			constraints.add(callerCheck(party.name) -> "Caller not authorized")
		if (tc !== null) {
			val ref = tc.reference
			if (ref instanceof Expression) {
				if (tc.timeframe === null)
					constraints.add(temporalCheck(tc.precedence, ref.compile, "0", false) -> temporalCheckReason(tc))
				else
					constraints.add(temporalCheck(tc.precedence, ref.compile, tc.timeframe.window.compile, tc.hasTimeFrame) -> temporalCheckReason(tc))
			}
			else if (ref instanceof ClauseQuery) {
				if (ref.status.equals(ClauseStatus.FAILED) || tc.precedence.equals(TemporalPrecedence.BEFORE))
					constraints.add(conditionalCheck("!(" + ref.clause.action.compoundAction.compile +")") -> "Clause " + ref.clause.name + " was fulfilled")
				else
					constraints.add(conditionalCheck(ref.clause.action.compoundAction.compile) -> "Clause " + ref.clause.name + " not fulfilled")	
				
				// TODO: temporal for failed case
				if (tc.timeframe === null)
					constraints.add(temporalCheck(tc.precedence, clauseFulfilledTime(ref.clause), "0", false) -> temporalCheckReason(tc))
				else
					constraints.add(temporalCheck(tc.precedence, clauseFulfilledTime(ref.clause), tc.timeframe.window.compile, tc.hasTimeFrame) -> temporalCheckReason(tc))
			}
			else if (ref instanceof EventQuery) {
				if (tc.precedence.equals(TemporalPrecedence.AFTER))
					constraints.add(conditionalCheck(callSuccess(ref.event.name.concat("Event"))) -> "Event " + ref.event.name + " did not occur")
				if (tc.precedence.equals(TemporalPrecedence.BEFORE))
					constraints.add(conditionalCheck("!" + callSuccess(ref.event.name.concat("Event"))) -> "Event " + ref.event.name + " already occurred")

				if (tc.timeframe === null)
					constraints.add(temporalCheck(tc.precedence, callTime(ref.event.name.concat("Event")), "0", false) -> temporalCheckReason(tc))
				else
					constraints.add(temporalCheck(tc.precedence, callTime(ref.event.name.concat("Event")), tc.timeframe.window.compile, tc.hasTimeFrame) -> temporalCheckReason(tc))
			}
			else if (ref instanceof ActionQuery) {
				val actionParty = interceptAttribute(ref.party, null) ?: ref.party.name
				if (tc.precedence.equals(TemporalPrecedence.AFTER)) {
					if (ref.party.name != "anyone")
						constraints.add(conditionalCheck(callCaller(ref.action.name) + " == " + actionParty + ".id") -> ref.party.type.name + " " + ref.party.name + " did not " + ref.action.name)
					constraints.add(conditionalCheck(callSuccess(ref.action.name)) -> "Action " + ref.action.name + " did not occur")
				}
				if (tc.precedence.equals(TemporalPrecedence.BEFORE)) {
					if (ref.party.name != "anyone")
						constraints.add(conditionalCheck(callCaller(ref.action.name) + " != " + actionParty + ".id") -> ref.party.type.name + " " + ref.party.name + " did " + ref.action.name)
					constraints.add(conditionalCheck("!" + callSuccess(ref.action.name)) -> "Action " + ref.action.name + " already occurred")
				}
				
				if (tc.timeframe === null)
					constraints.add(temporalCheck(tc.precedence, callTime(ref.action.name), "0", false) -> temporalCheckReason(tc))
				else
					constraints.add(temporalCheck(tc.precedence, callTime(ref.action.name), tc.timeframe.window.compile, tc.hasTimeFrame) -> temporalCheckReason(tc))
			}	
		}
		if (gc !== null)
			constraints.add(conditionalCheck(gc.expression.compile) -> "Given condition(s) not met")
		constraints
	}

	def compileEventFunctions(CmlClass c) '''
		«FOR e : c.attributes.filter[type.mapsToEvent] SEPARATOR "\n" AFTER "\n"»
			«e.compileEventAsFunction»
		«ENDFOR»
	'''
	
	def compileStaticFunctions(CmlClass c) '''
		«FOR o : c.staticOperations SEPARATOR "\n" AFTER "\n"»
			«o.compile(o.deriveAnnotations, newLinkedHashMap)»
		«ENDFOR»
	'''

	def compileFunctions(CmlClass c) '''
		«FOR cl : c.clauses»
			«FOR aa : cl.action.compoundAction.eAllOfType(AtomicAction) SEPARATOR "\n" AFTER "\n"»
				// @notice function for clause «cl.name»
				«aa.operation.compile(aa.operation.deriveAnnotations, cl.deriveModifiers)»
			«ENDFOR»
		«ENDFOR»
	'''

	def String compileEnums(CmlClass c) '''
		«FOR a : c.gatherEnums BEFORE "/*\n * Enums\n */\n" SEPARATOR "" AFTER "\n"»
			«a.compileEnum»
		«ENDFOR»
	'''
	
	def String compileStructs(CmlClass c) '''
		«FOR entry : c.gatherStructs BEFORE "/*\n * Structs\n */\n" SEPARATOR "\n" AFTER "\n"»
			«entry.compile»
		«ENDFOR»
	'''
	
	def Set<CmlClass> gatherEnums(CmlClass c) {
		var set = newLinkedHashSet
		set.addAll(c.referencedNamedElements.map[inferType].filter[mapsToEnum])
		for(entry : c.referencedNamedElements.map[inferType].filter[mapsToStruct])
			set.addAll(entry.traverseForEnums)
		set
	}
	
	def Set<CmlClass> traverseForEnums(CmlClass c) {
		var set = newLinkedHashSet
		for(class : c.attributes.map[type]) {
			if (class.mapsToEnum)
				set.add(class)
			set.addAll(traverseForEnums(class))
		}
		set
	}

	def Set<CmlClass> gatherStructs(CmlClass c) {
		var set = newLinkedHashSet
		set.addAll(c.referencedNamedElements.map[inferType].filter[!conformsToVoid].filter[mapsToStruct])
		for(entry : c.referencedNamedElements.map[inferType].filter[mapsToStruct])
			set.addAll(entry.traverseForStructs)
		set
	}
	
	def Set<CmlClass> traverseForStructs(CmlClass c) {
		var set = newLinkedHashSet
		for(class : c.attributes.filter[type.mapsToStruct].map[type]) {
			set.add(class)
			set.addAll(traverseForStructs(class))
		}
		set
	}
	
	def Set<NamedElement> referencedNamedElements(CmlClass c) {
		var set = new LinkedHashSet<NamedElement>
		set.addAll(c.attributes)
		set.addAll(c.operations)
		set.addAll(c.operations.map[params].flatten)
		for(o : c.operations) {
			set.addAll(o.traverseForTypes)
		}
		set
	}
	
	def Set<NamedElement> traverseForTypes(Operation o) {
		var set = new LinkedHashSet<NamedElement>
		set.addAll(o.referencedSymbols)
		set.addAll(o.variableDeclarations)
		for(op : o.referencedOperations) {
			if (op !== o)
				set.addAll(traverseForTypes(op))
		}
		set
	}
	
	def Set<Operation> staticOperations(CmlClass c) {
		c.referencedNamedElements.filter(Operation).filter[static && !containedInMainLib].toSet
	}
	
	def Set<Attribute> staticAttributes(CmlClass c) {
		c.referencedNamedElements.filter(Attribute).filter[static].toSet
	}
	
	def mapsToStruct(CmlClass c) {
		!c.conformsToLibraryType && !c.conformsToToken && !c.mapsToEnum && !c.conformsToTokenTransaction
	}
	
	def mapsToEnum(CmlClass c) {
		c.conformsToEnum || c.subclassOfEnum
	}
	
	def mapsToEvent(CmlClass c) {
		c.conformsToEvent || c.subclassOfEvent
	}
	
	def compileAttributes(CmlClass c) '''
		«FOR a : c.staticAttributes»
			«a.compile»;
		«ENDFOR»
		«FOR a : c.attributes.filter[!type.mapsToEnum]»
			«a.compile»;
		«ENDFOR»
	'''

	def compileEvents(CmlClass c) '''
		«FOR e : c.attributes.filter[type.mapsToEvent] BEFORE "/*\n * Events\n */\n" AFTER "\n"»
			event «e.name.toFirstUpper»Event(«e.type.name» «e.name»);
		«ENDFOR»
	'''

	def compileConstructor(CmlClass c) {
		val initOperation = c.operations.findFirst[name == "init"]
		if (initOperation !== null)
			initOperation.compileInitConstructor
		else
			c.compileStandardConstructor
	}

	def compileInitConstructor(Operation o) '''	
		constructor(«o.params.compile») «FOR a : o.deriveAnnotations SEPARATOR ' '»«a»«ENDFOR» {
			«FOR s : o.body?.statements ?: emptyList»
				«compileStatement(s)»
			«ENDFOR»
			_contractStart = now;
		}
	'''

	def compileStandardConstructor(CmlClass c) '''
		constructor() public {
			_contractStart = now;
		}
    '''

	def compileStates(CmlClass c) '''
		«FOR s : c.clauses.indexed»
			bytes32 constant STATE«s.key» = "«s.value.name»";
		«ENDFOR»
		bytes32[] states = [«FOR s : c.clauses.indexed SEPARATOR ", "»STATE«s.key»«ENDFOR»];
		
	'''
	
	def String compile(CompoundAction ca) {
		switch (ca) {
			XorCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				left + " != " + right
			}
			OrCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				left + " || " + right
			}
			AndCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				left + " && " + right
			}
			NestedCompoundAction: {
				"(" + ca.child.compile + ")"
			}
			AtomicAction:
				callSuccess(ca.operation.name)
		}
	}
	
	def compile(List<Attribute> attributes) '''
		«FOR a : attributes SEPARATOR ', '»«IF !a.type.conformsToTokenTransaction»«a.compile»«ENDIF»«ENDFOR»'''

	def compile(Attribute a) {
		interceptAttribute(a, null) ?: '''«(a.type as Type).compile»«IF a.constant» constant«ENDIF»«IF a.type.mapsToStruct && a.containingOperation !== null» memory«ENDIF» «a.name»«IF a.expression !== null» = «a.expression.compile»«ENDIF»'''
	}

	def compile(CmlClass c) '''
		struct «c.name.toFirstUpper» {
			«FOR a : c.classHierarchyAttributes.values»
				«val value = a.compile»
				«IF (!value.nullOrEmpty)»«(value + ";")»«ENDIF»
	   		«ENDFOR»
		}
	'''
	
	def compile(Operation o, List<String> annotations, LinkedHashMap<String, List<String>> modifiers) '''	
		function «o.name»(«o.params.compile») «FOR a : annotations SEPARATOR ' '»«a»«ENDFOR»
			«FOR m : modifiers.entrySet SEPARATOR ' '»
				«m.key»(«m.value.join(", ")»)
			«ENDFOR»
			«IF o.type !== null»returns («(o.type as Type).compile»«IF o.type.mapsToStruct» memory«ENDIF»)«ENDIF»
		{
			«FOR s : o.body?.statements ?: emptyList»
				«compileStatement(s)»
			«ENDFOR»
		}
	'''
	
	def compileOperationParams(List<Attribute> attributes) '''
		«FOR a : attributes SEPARATOR ', '»
			«IF !a.type.mapsToStruct»«ENDIF»
		«ENDFOR»
	'''
	
	def payable(Operation o) {
		o.eAllOfType(Statement).filter(FeatureSelection)?.filter[opCall && feature instanceof Operation]?.map[feature]?.
			findFirst[containingClass.conformsToParty && name == "deposit"] !== null
	}
	
//	def modifiesStateAttributes(Operation o) {
//		!o.eAllOfType(AssignmentExpression).map[left].filter(SymbolReference).map[symbol].filter(Attribute).filter[!static].empty
//	}
	
	def List<String> deriveAnnotations(Operation o) {
		var list = newArrayList
		list.add("public")
		if (o.payable)
			list.add("payable")
		else if (o.static) 
			list.add("pure")
//		else if (!o.modifiesStateAttributes) // TODO
//			list.add("view")
		list
	}

	def deriveModifiers(Clause c) {
		var modifiers = new LinkedHashMap<String, List<String>>()
		var list = newArrayList
		list.add("\""+c.name+"\"")
		modifiers.put("checkAllowed", list)
		modifiers
	}
	
	def compileBlock(Block block) '''
		{	
			«FOR s : block.statements»
				«s.compileStatement»
			«ENDFOR»
		}
	'''
	
	def String compileStatement(Statement s) {
		switch (s) {
			VariableDeclaration: '''«(s.type as Type).compile» «s.name» = «s.expression.compile»;'''
			ReturnStatement:
				"return (" + s.expression.compile + ");"
			IfStatement: '''
				if («s.condition.compile»)
				«s.thenBlock.compileBlock»
				«IF s.elseBlock !== null»
					else
					«s.elseBlock.compileBlock»
				«ENDIF»
			'''
			SwitchStatement: '''
				«FOR c : s.cases.indexed»
					«IF c.key == 0»if «ELSE»else if«ENDIF»(«s.declaration.compile» == «c.value.^case.compile»)
					«c.value.thenBlock.compileBlock»
				«ENDFOR»
				«IF s.^default»
					else
					«s.defaultBlock.compileBlock»
				«ENDIF»
			'''
			DoWhileStatement: '''
				do
				«s.block.compileBlock»
				while («s.condition.compile»);
			'''
			WhileStatement: '''
				while («s.condition.compile»)
				«s.block.compileBlock»
			'''
			ForStatement: '''
				for («s.declaration.compileStatement» «s.condition.compile»; «s.progression.compile»)
				«s.block.compileBlock»
			'''
			ThrowStatement: '''revert(«s.expression?.compile»);'''
			default: {
				val statement = (s as Expression).compile
				if (!statement.nullOrEmpty) (statement + ";") else ""
			}
		}
	}

	def compileEventAsFunction(Attribute a) '''
		// @notice trigger event «a.type.name»
		function «a.name.toFirstLower»Event(«a.type.name» memory _«a.name») public postCall
		{
			«a.name» = _«a.name»;
			emit «a.name.toFirstUpper»Event(«a.name»);
		}
	'''

	def compileEnum(CmlClass c) '''
		enum «c.name.toFirstUpper» { «FOR e : c.enumElements SEPARATOR ', '»«e.name»«ENDFOR» } «c.name.toFirstUpper» «c.name.toFirstLower»;
	'''

	def compile(Type t) {
		switch (t) {
			CmlClass:
				switch (t) {
					case t.conformsToInteger: "uint" // "int"
					case t.conformsToBoolean: "bool"
					case t.conformsToString: "bytes32"
					case t.conformsToReal: if (fixedPointArithmetic) "uint" else "ufixed" //"fixed"
					case t.conformsToDateTime: "uint"
					case t.conformsToDuration: "uint"
					case t.conformsToNumber: "uint"
					default: t.name
				}
		}
	}

	def retrieveImport(Iterable<CmlProgram> resources, Import i) {
		if (i.importedNamespace !== CmlLib::LIB_PACKAGE)
			resources.findFirst[name == i.copy.importedNamespace.replace(".*", "")]
	}

	def gatherImportedResources(CmlProgram program) {
		var list = newArrayList
		for (import : program.imports) {
			list += this.allResources.retrieveImport(import)
		}
		list
	}

	def String compile(Expression exp) {
		switch (exp) {
			AssignmentExpression: '''«(exp.left.compile)» = «(exp.right.compile)»'''
			OrExpression: '''«(exp.left.compile)» || «(exp.right.compile)»'''
			AndExpression: '''«(exp.left.compile)» && «(exp.right.compile)»'''
			EqualityExpression: {
				if (exp.op == '==')
					'''«(exp.left.compile)» == «(exp.right.compile)»'''
				else
					'''«(exp.left.compile)» != «(exp.right.compile)»'''
			}
			RelationalExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				switch (exp.op) {
					case '<': '''«left» < «right»'''
					case '>': '''«left» > «right»'''
					case '>=': '''«left» >= «right»'''
					case '<=': '''«left» <= «right»'''
					default:
						""
				}
			}
			AdditiveExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				if (safeMath && !fixedPointArithmetic)
					switch (exp.op) {
						case '+': '''SafeMath.add(«(left)», «(right)»)'''
						case '-': '''SafeMath.sub(«(left)», «(right)»)'''
					}
				else if (fixedPointArithmetic) // fixedPointArithmetic uses safeMath ops per default 
					switch (exp.op) {
						case '+': '''FPMath.add(«(left)», «(right)»)'''
						case '-': '''FPMath.sub(«(left)», «(right)»)'''
					}	
				else
					switch (exp.op) {
						case '+': '''«(left)» + «(right)»'''
						case '-': '''«(left)» - «(right)»'''
					}
			}
			MultiplicativeExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				if (safeMath && !fixedPointArithmetic)
					switch (exp.op) {
						case '*': '''SafeMath.mul(«(left)», «(right)»)'''
						case '/': '''SafeMath.div(«(left)», «(right)»)'''
						case '%': '''SafeMath.mod(«(left)», «(right)»)'''
						case '**': '''«(left)» ** «(right)»''' // TODO
					}
				else if (fixedPointArithmetic) // fixedPointArithmetic uses safeMath ops per default 
					switch (exp.op) {
						case '*': '''FPMath.fpmul(«(left)», «(right)», «(fixedPointDecimals)»)'''
						case '/': '''FPMath.fpdiv(«(left)», «(right)», «(fixedPointDecimals)»)'''
						case '%': '''SafeMath.mod(«(left)», «(right)»)'''
						case '**': '''FPMath.fppow(«(left)», «(right)», «(fixedPointDecimals)»)'''
					}
				else
					switch (exp.op) {
						case '*': '''«left» * «right»'''
						case '/': '''«(left)» / «(right)»'''
						case '%': '''«(left)» % «(right)»'''
						case '**': '''«(left)» ** «(right)»'''
					}
			}
			UnaryExpression: {
				switch (exp.op) {
					case '+': ''' +«(exp.operand.compile)»'''
					case '-': ''' -«(exp.operand.compile)»'''
					case '!',
					case 'not': ''' !«(exp.operand.compile)»'''
				}
			}
			PostfixExpression: {
				if (exp.op == '++')
					'''«(exp.operand.compile)»++'''
				else
					'''«(exp.operand.compile)»--'''
			}
			CastedExpression: '''«exp.target.compile»'''
			NestedExpression: '''(«exp.child.compile»)'''
			RealLiteral:
				if (fixedPointArithmetic)
					'''«fixedPointRepresentation(exp.value)»'''
				else
					'''«exp.value»'''
			IntegerLiteral:
				if (fixedPointArithmetic)
					'''«fixedPointRepresentation(BigDecimal.valueOf(exp.value))»'''
				else
					'''«exp.value»'''
			BooleanLiteral: '''«exp.value»'''
			StringLiteral: '''"«exp.value»"'''
			SuperExpression: '''super'''
			ThisExpression: '''this''' // concept doesn't exist in the same manner in solidity
			DateTimeLiteral: '''«exp.compile»'''
			DurationLiteral: '''«exp.value» «exp.unit»'''
			SymbolReference: '''«exp.compile»'''
			FeatureSelection: '''«exp.compile»'''
		}
	}
	
	def compile(DateTimeLiteral dtl) {
		Instant.parse(dtl.value + "T00:00:00.00Z").getEpochSecond();
	}

	def fixedPointRepresentation(BigDecimal b) {
		b.scaleByPowerOfTen(fixedPointDecimals).toString().replace("E+", "E")
	}
	
	def resolvePath(FeatureSelection fs) {
		val list = newLinkedList
		list.add(fs.feature)
		var current = fs.receiver
		while (current !== null) {
			if (current instanceof FeatureSelection) {
				list.add(current.feature)
				current = current.receiver
			} else if (current instanceof SymbolReference) {
				list.add(current.symbol)
				current = null
			} else {
				current = null
			}
		}
		list
	}
	
	def resolvePath(Expression e) {
		if (e instanceof FeatureSelection) {
			e.resolvePath
		} else if (e instanceof SymbolReference) {
			#[e.symbol]
		}
	}
 	
	def compile(FeatureSelection fs) {
		var String rslt

		if (!fs.opCall && fs.feature instanceof Attribute)
			rslt = interceptAttribute(fs.feature as Attribute, fs)

		if (fs.opCall && fs.feature instanceof Operation)
			rslt = interceptOperation(fs.feature as Operation, fs.args, fs.receiver)

		rslt ?: {
			rslt = fs.receiver.compile + "." + fs.feature.name + if (fs.opCall) {
				"(" + fs.args.map[compile].join(", ") + ")"
			} else
				""
		}
	}

	def compile(SymbolReference sr) {
		var String rslt

		if (!sr.opCall && sr.symbol instanceof Attribute)
			rslt = interceptAttribute(sr.symbol as Attribute, sr)

		if (sr.opCall && sr.symbol instanceof Operation)
			rslt = interceptOperation(sr.symbol as Operation, sr.args, sr)

		if (sr.opCall && sr.symbol instanceof CmlClass)
			rslt = interceptClass(sr.symbol as CmlClass, sr.args, sr)

		rslt ?: {
			sr.symbol.name + if (sr.opCall) {
				"(" + sr.args.map[compile].join(", ") + ")"
			} else
				""
		}
	}

	def interceptClass(CmlClass c, List<Expression> args, SymbolReference reference) {
		switch (c) {
			case c.conformsToError: {
				args.get(0).compile
			}
			case c.subclassOfParty: {
				args.remove(1)
				reference.symbol.name + "(" + args.map[compile].join(", ") + ")"
			}
		}
	}

	def interceptAttribute(Attribute a, Expression reference) {
		val c = a.containingClass
		if (c !== null) {
			if (c.conformsToContract) {
				switch (a.name) {
					case "contractStart": "_contractStart"
					case "caller": "Party(msg.sender)"
				}
			} else if (c.conformsToParticipant) {
				switch (a.name) {
					case "id": if (reference === null) "address payable id"
				}
			} else if (c.conformsToAsset) {
				switch (a.name) {
					case "quantity": if (reference !== null) "address(this).balance"
				}
			} else if (c.conformsToTransaction) {
				switch (a.name) {
					case "sender": if (reference === null) "" else "Party(msg.sender)"
				}
			} else if (c.conformsToTokenHolder) {
				switch (a.name) {
					case "token": ""
				}
			} else if (c.conformsToTokenTransaction) {
				switch (a.name) {
					case "amount": if (reference === null) "" else "msg.value"
				}
			}
		}
	}
	
	def interceptOperation(Operation o, List<Expression> args, Expression reference) {
		if (!o.static) {
			val c = o.containingClass
			val path = reference.resolvePath
			
			if (c.conformsToParty) {
				switch (o.name) {
					case "deposit": ""
					case "withdraw": {
						if (pullPayment) {
							"_asyncTransfer(" + reference.compile + ".id , " + args.get(0).compile + ")"
						} else {
							reference.compile + ".id.transfer" + "(" + args.get(0).compile + ")"
						}
					}
				}
			} else if (c.conformsToContract) {
				switch (o.name) {
					case "transfer": {
						if (pullPayment) {
							"_asyncTransfer(" + args.get(0).compile + ".id , " + args.get(1).compile + ")"
						} else {
							args.get(0).compile + ".id.transfer" + "(" + args.get(1).compile + ")"
						}
					}
				}
			} else if (c.conformsToNumber) {
				switch (o.name) {
					case "toInteger": {
						if (path.get(0).inferType.conformsToInteger || path.get(0).inferType.conformsToNumber)
							reference.compile
						else if (path.get(0).inferType.conformsToReal)
							if(fixedPointArithmetic) "RealLib.toInteger(" + reference.compile + ", " +
								fixedPointDecimals + ")" else "??? Not yet implemented"
					}
					case "toReal": {
						if (path.get(0).inferType.conformsToInteger)
							if(fixedPointArithmetic) "IntLib.toReal(" + reference.compile +
								")" else "??? Not yet implemented"
						else if (path.get(0).inferType.conformsToReal || path.get(0).inferType.conformsToNumber)
							reference.compile
					}
				}
			} else if (c.conformsToInteger) {
				switch (o.name) {
					case "average": "IntLib.average(" + reference.compile + ", " + args.get(0).compile + ")"
					case "max": "IntLib.max(" + reference.compile + ", " + args.get(0).compile + ")"
					case "min": "IntLib.min(" + reference.compile + ", " + args.get(0).compile + ")"
				}
			} else if (c.conformsToReal) {
				switch (o.name) {
					case "max": "RealLib.max(" + reference.compile + ", " + args.get(0).compile + ")"
					case "min": "RealLib.min(" + reference.compile + ", " + args.get(0).compile + ")"
					case "sqrt": "RealLib.sqrt(" + reference.compile + ")"
					case "ceil": if (fixedPointArithmetic) "RealLib.ceil(" + reference.compile + ", " + fixedPointDecimals+ ")" else "??? Not yet implemented"
					case "floor": if (fixedPointArithmetic) "RealLib.floor(" + reference.compile + ", " + fixedPointDecimals+ ")" else "??? Not yet implemented"
				}
			} else if (c.conformsToDateTime) {
				switch (o.name) {
					case "isBefore": "DateTime.isBefore(" + reference.compile + ", " + args.get(0).compile + ")"
					case "isAfter": "DateTime.isAfter(" + reference.compile + ", " + args.get(0).compile + ")"
					case "second": "DateTime.getSecond(" + reference.compile + ")"
					case "minute": "DateTime.getMinute(" + reference.compile + ")"
					case "hour": "DateTime.getHour(" + reference.compile + ")"
					case "day": "DateTime.getDay(" + reference.compile + ")"
					case "week": "DateTime.getWeek(" + reference.compile + ")"
					case "equals": "DateTime.equals(" + reference.compile + ", " + args.get(0).compile + ")"
					case "addDuration": "DateTime.addDuration(" + reference.compile + ", " + args.get(0).compile + ")"
					case "subtractDuration": "DateTime.subtractDuration(" + reference.compile + ", " +
						args.get(0).compile + ")"
					case "durationBetween": "DateTime.durationBetween(" + reference.compile + ", " +
						args.get(0).compile + ")"
				}
			} else if (c.conformsToDuration) {
				switch (o.name) {
					case "toSeconds": reference.compile
					case "toMinutes": "DateTime.toMinutes(" + reference.compile + ")"
					case "toHours": "DateTime.toHours(" + reference.compile + ")"
					case "toDays": "DateTime.toDays(" + reference.compile + ")"
					case "toWeeks": "DateTime.toWeeks(" + reference.compile + ")"
					case "addDuration": "DateTime.addDuration(" + reference.compile + ", " + args.get(0).compile + ")"
					case "subtractDuration": "DateTime.subtractDuration(" + reference.compile + ", " +
						args.get(0).compile + ")"
				}
			}
		} else {
			if (o.containedInMainLib) {
				switch (o.name) {
					case "ensure": "require(" + args.get(0).compile + ", " + args.get(1).compile + ")"
				}

			}
		}
	}
}
