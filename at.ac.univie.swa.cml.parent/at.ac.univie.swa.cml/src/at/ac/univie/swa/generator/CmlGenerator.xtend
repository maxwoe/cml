/*
 * generated by Xtext 2.16.0
 */
package at.ac.univie.swa.generator

import at.ac.univie.swa.CmlLib
import at.ac.univie.swa.CmlModelUtil
import at.ac.univie.swa.cml.ActionQuery
import at.ac.univie.swa.cml.AdditiveExpression
import at.ac.univie.swa.cml.AndCompoundAction
import at.ac.univie.swa.cml.AndExpression
import at.ac.univie.swa.cml.ArrayAccessExpression
import at.ac.univie.swa.cml.AssignmentExpression
import at.ac.univie.swa.cml.AtomicAction
import at.ac.univie.swa.cml.Attribute
import at.ac.univie.swa.cml.Block
import at.ac.univie.swa.cml.BooleanLiteral
import at.ac.univie.swa.cml.CastedExpression
import at.ac.univie.swa.cml.Clause
import at.ac.univie.swa.cml.ClauseQuery
import at.ac.univie.swa.cml.ClauseStatus
import at.ac.univie.swa.cml.CmlClass
import at.ac.univie.swa.cml.CmlFactory
import at.ac.univie.swa.cml.CmlProgram
import at.ac.univie.swa.cml.CompoundAction
import at.ac.univie.swa.cml.DateTimeLiteral
import at.ac.univie.swa.cml.Deontic
import at.ac.univie.swa.cml.DoWhileStatement
import at.ac.univie.swa.cml.DurationLiteral
import at.ac.univie.swa.cml.EqualityExpression
import at.ac.univie.swa.cml.EventQuery
import at.ac.univie.swa.cml.Expression
import at.ac.univie.swa.cml.FeatureSelectionExpression
import at.ac.univie.swa.cml.ForBasicStatement
import at.ac.univie.swa.cml.ForLoopStatement
import at.ac.univie.swa.cml.GenericArrayTypeReference
import at.ac.univie.swa.cml.IfStatement
import at.ac.univie.swa.cml.Import
import at.ac.univie.swa.cml.IntegerLiteral
import at.ac.univie.swa.cml.MultiplicativeExpression
import at.ac.univie.swa.cml.NamedElement
import at.ac.univie.swa.cml.NestedCompoundAction
import at.ac.univie.swa.cml.NestedExpression
import at.ac.univie.swa.cml.NewExpression
import at.ac.univie.swa.cml.NullLiteral
import at.ac.univie.swa.cml.Operation
import at.ac.univie.swa.cml.OrCompoundAction
import at.ac.univie.swa.cml.OrExpression
import at.ac.univie.swa.cml.ParameterizedTypeReference
import at.ac.univie.swa.cml.PostfixExpression
import at.ac.univie.swa.cml.RealLiteral
import at.ac.univie.swa.cml.ReferenceExpression
import at.ac.univie.swa.cml.RelationalExpression
import at.ac.univie.swa.cml.ReturnStatement
import at.ac.univie.swa.cml.Statement
import at.ac.univie.swa.cml.StringLiteral
import at.ac.univie.swa.cml.SuperExpression
import at.ac.univie.swa.cml.SwitchStatement
import at.ac.univie.swa.cml.TemporalConstraint
import at.ac.univie.swa.cml.TemporalPrecedence
import at.ac.univie.swa.cml.ThisExpression
import at.ac.univie.swa.cml.Type
import at.ac.univie.swa.cml.TypeReference
import at.ac.univie.swa.cml.UnaryExpression
import at.ac.univie.swa.cml.VariableDeclaration
import at.ac.univie.swa.cml.WhileStatement
import at.ac.univie.swa.cml.XorCompoundAction
import at.ac.univie.swa.typing.CmlTypeConformance
import at.ac.univie.swa.typing.CmlTypeProvider
import com.google.inject.Inject
import java.io.InputStream
import java.math.BigDecimal
import java.time.Instant
import java.util.LinkedHashMap
import java.util.LinkedHashSet
import java.util.LinkedList
import java.util.List
import java.util.Scanner
import java.util.Set
import org.apache.log4j.Logger
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CmlGenerator extends AbstractGenerator2 {

	static final Logger LOG = Logger.getLogger(CmlGenerator)
	static final String MODEL_NAME = "Model"
	static val GLOBAL_ID_TYPE = CmlFactory::eINSTANCE.createCmlClass => [name = "address"]
	int fixedPointDecimals
	boolean fixedPointArithmetic
	boolean safeMath
	boolean pullPayment
	boolean ownable
	boolean detachModel
	@Inject extension CmlModelUtil
	@Inject extension CmlTypeConformance
	@Inject extension CmlTypeProvider
	Iterable<CmlProgram> allResources
	IFileSystemAccess2 fsa
	
	override doGenerate(Resource resource, ResourceSet input, IFileSystemAccess2 fsa, IGeneratorContext context) {
		LOG.info("resource: " + resource)
		println("resource: " + resource.URI)
				
		allResources = input.resources.map(r|r.allContents.toIterable.filter(CmlProgram)).flatten
		this.fsa = fsa
		
		for (p : resource.allContents.toIterable.filter(CmlProgram)) {
			if (!p.contracts.empty) {
				fsa.generateFile("/" + resource.URI.trimFileExtension.segmentsList.last + ".sol", p.compile)
			}
		}
	}
	
	def addLibFromResources(String resourceName) {
		fsa.generateFile("/lib/" + resourceName, getResource(resourceName))
	}
	
	def getResource(String resourceName) {
		val url = class.classLoader.getResource(resourceName)
		val inputStream = url.openStream
		try {
			inputStream.convertToString
		} finally {
			inputStream.close()
		}
	}
	
	def static convertToString(InputStream is) {
		val Scanner s = new Scanner(is).useDelimiter("\\A")
		if (s.hasNext()) s.next() else ""
	}

	def deriveInheritance(CmlClass c) {
		var list = newLinkedList
		list.add("ConditionalContract")
		if (ownable)
			list.add("Ownable")
		if (pullPayment)
			list.add("PullPayment")
		list
	}
	
	def initGeneratorSettings() {
		fixedPointDecimals = 2
		fixedPointArithmetic = false
		safeMath = false
		pullPayment = false
		ownable = false
		detachModel = true
	}
	
	def deriveGeneratorSettings(CmlClass c) {
		initGeneratorSettings
		for (a : c.annotations) {
			val declaration = a.declaration
			switch (declaration.name) {
				case "SafeMath":
					safeMath = true
				case "FixedPointArithmetic": {
					fixedPointArithmetic = true
					if (!a.args.empty) {
						val integerLiteral = a.args.get(0).value
						if (integerLiteral instanceof IntegerLiteral)
							fixedPointDecimals = integerLiteral.value
					}
				}
				case "Ownable":
					ownable = true
				case "PullPayment":
					pullPayment = true
			}
		}
	}
	
	def buildImports(CmlClass c) {
		val imports = new LinkedHashSet<String>()
		addLibFromResources("cml/ConditionalContract.sol")
		imports.add("./lib/cml/ConditionalContract.sol")
		addLibFromResources("cml/DateTime.sol")
		imports.add("./lib/cml/DateTime.sol")
		addLibFromResources("cml/IntLib.sol")
		imports.add("./lib/cml/IntLib.sol")
		addLibFromResources("cml/RealLib.sol")
		imports.add("./lib/cml/RealLib.sol")

		if(ownable) {
			addLibFromResources("openzeppelin/Ownable.sol")
			imports.add("./lib/openzeppelin/Ownable.sol")
		}
		
		if(pullPayment) {
			addLibFromResources("openzeppelin/Escrow.sol")
			addLibFromResources("openzeppelin/Secondary.sol")
			addLibFromResources("openzeppelin/PullPayment.sol")
			addLibFromResources("openzeppelin/SafeMath.sol")
			imports.add("./lib/openzeppelin/PullPayment.sol")
		}
		
		if(safeMath) {
			addLibFromResources("openzeppelin/SafeMath.sol")
			imports.add("./lib/openzeppelin/SafeMath.sol")
		}
		
		if(fixedPointArithmetic) {
			addLibFromResources("cml/FPMath.sol")
			imports.add("./lib/cml/FPMath.sol")
		}
		
		if(detachModel && !c.gatherStructs.isEmpty) {
			fsa.generateFile("/lib/cml/" + MODEL_NAME + ".sol", compileModelLibrary(c))
			imports.add("./lib/cml/" + MODEL_NAME + ".sol")
		}
		
		for (a : c.attributes.filter[inferType.conformsToMap]) {
			val rslt = a.type.resolveKeyValue.keyValueTransformation
			var key = rslt.key
			val value = rslt.value
			val mapImplName = a.compileMapImplName
			fsa.generateFile("/lib/cml/" + mapImplName + ".sol", compileMapLib(mapImplName, key, value))
			fsa.generateFile("/lib/cml/" + "CLL" + (key as Type).compile.toFirstUpper + ".sol",	compileCLLLib("CLL" + (key as Type).compile.toFirstUpper, key))
			imports.add("./lib/cml/" + mapImplName + ".sol")
		}
		
		imports
	}
	
	def keyValueTransformation(Pair<CmlClass,CmlClass> pair) {
		var key = pair.key
		val value = pair.value
		if (value.conformsToParty || value.subclassOfParty)
			key = GLOBAL_ID_TYPE
		new Pair(key, value)
	}
	
	def resolveKeyValue(TypeReference tr) {
		var CmlClass key = null
		var CmlClass value = null
		if(tr instanceof GenericArrayTypeReference) {
			value = tr.componentType.inferType
			key = value.resolveIdentifierType		
		}
		if(tr instanceof ParameterizedTypeReference) {
			key = (tr as ParameterizedTypeReference).typeArgs.get(0).inferType
			value = (tr as ParameterizedTypeReference).typeArgs.get(1).inferType
		}
		return new Pair(key, value)
	}
	
	def compileMapImplName(Attribute a) {
		val rslt = a.type.resolveKeyValue.keyValueTransformation
		compileMapImplName(rslt.key, rslt.value)
	}
				
	def compileMapImplName(Type key, Type value) {
		("Map" + key.compile.toFirstUpper + value.compile.toFirstUpper).replace(MODEL_NAME + ".", "")
	}
	
	def compileModelLibrary(CmlClass c) '''
		pragma solidity >=0.4.22 <0.7.0;
		
		library «MODEL_NAME» {
			«c.compileEnums»
			«c.compileStructs»
		}
	'''
	
	def compileImports(CmlClass c) '''
		«FOR i : buildImports(c)»
			import "«i»";
		«ENDFOR»
	'''
	
	def compile(CmlProgram program) '''
		pragma solidity >=0.4.22 <0.7.0;
		pragma experimental ABIEncoderV2;
		«FOR contract : program.contracts»
			«contract.deriveGeneratorSettings»
			«contract.compileImports»
			
			contract «contract.name»«FOR a : contract.deriveInheritance BEFORE " is " SEPARATOR ", "»«a»«ENDFOR» {
			
				«IF !detachModel»«contract.compileEnums»«ENDIF»
				«IF !detachModel»«contract.compileStructs»«ENDIF»
				«contract.compileEvents»
				«"/*\n * State variables\n */\n"»
				«contract.compileAttributes»
				uint _contractStart;
				
				«"/*\n * Constructor\n */\n"»
				«contract.compileConstructor»
				
				«"/*\n * Functions\n */\n"»
				«contract.compileFunctions»
				«contract.compileEventFunctions»
				«contract.compileStaticFunctions»
				// Fallback function
				function() external payable {}
				
				«contract.compileClauseConstraints»
				«contract.compileClauseFulfilledTime»
				«contract.compileContractObeyed»
			}
		«ENDFOR»
	'''

	def compileClauseConstraints(CmlClass c) '''
		function clauseAllowed(bytes32 _clauseId) internal returns (bool) {
			«FOR clause : c.clauses»
				if (_clauseId == "«clause.name»") {
					«FOR constraint : clause.deriveConstraints»
						require(«constraint.key»«IF !constraint.value.nullOrEmpty», "«constraint.value»"«ENDIF»);
					«ENDFOR»
					return true;
				}
	   		«ENDFOR»		      
			return false;
		}

	'''

	def compileClauseFulfilledTime(CmlClass c) '''
		function clauseFulfilledTime(bytes32 _clauseId) internal returns (uint) {
			uint max = 0;
			«FOR clause : c.clauses»
				if (_clauseId == "«clause.name»" && («clause.action.compoundAction.compile»)) {
					«var actions = clause.action.compoundAction.eAllOfType(AtomicAction).map[operation.name]»
					«FOR a : actions»
						if (max < «callTime(a)») {
							max =  «callTime(a)»;
						}
					«ENDFOR»
					return max;
				}
	   		«ENDFOR»		      
			return max;
		}

	'''
	
	def compileContractObeyed(CmlClass c) '''
		function contractObeyed() internal returns (bool) {
			«FOR clause : c.clauses.filter[clause | clause.action.deontic.equals(Deontic.MUST) && !c.reparationClauses.exists[it === clause.name]]»
				«val tc = clause.constraint.temporal»
«««				TODO: ClauseQuery failed handling
				if («IF !(tc.reference instanceof Expression)»«tc.reference.deriveReferenceCompletionTime» != 0  && «ENDIF»now > «tc.completionTime») {
					require(«clause.action.compoundAction.compile», "CONTRACT BREACHED: Clause «clause.name» not fulfilled");
				}
	   		«ENDFOR»		      
			return true;
		}

	'''
	
	def reparationClauses(CmlClass c) {
		c.clauses.filter [it.constraint.temporal.reference instanceof ClauseQuery &&
				(it.constraint.temporal.reference as ClauseQuery).status.equals(ClauseStatus.FAILED)
		].map[(it.constraint.temporal.reference as ClauseQuery).clause.name]
	}
	
	def completionTime(TemporalConstraint tc) {
		if(tc.precedence.equals(TemporalPrecedence.AFTER))
			"DateTime.addDuration(" + tc.reference.deriveReferenceCompletionTime + ", " + tc.timeframe.window.compile + ")"
		else if (tc.precedence.equals(TemporalPrecedence.BEFORE))
			tc.reference.deriveReferenceCompletionTime
	}
	
	def String deriveReferenceCompletionTime(EObject reference) {
		if(reference instanceof Expression)
			reference.compile
		else if(reference instanceof ClauseQuery)
			clauseFulfilledTime(reference.clause)
		else if(reference instanceof EventQuery)
			callTime(reference.event.name.concat("Event"))
		else if(reference instanceof ActionQuery)
			callTime(reference.action.name)
	}
		
	def temporalCheckReason(TemporalConstraint tc) {
		if (tc.precedence.equals(TemporalPrecedence.AFTER) && !tc.hasTimeFrame)
			"Function called too early"
		else if (tc.precedence.equals(TemporalPrecedence.BEFORE) && !tc.hasTimeFrame)
			"Function called too late"
		else "Function not called within expected timeframe"
	}
	
	def temporalCheck(TemporalPrecedence precedence, String time, String duration, boolean within) {
		"only" + precedence.literal.toFirstUpper + "(" + time + ", " + duration + ", " + within.booleanValue + ")"
	}
	
	def conditionalCheck(String condition) {
		condition
	}
	
	def callerCheck(String account) {
		"onlyBy(" + account +  ".id" + ")"
	}
	
	def callSuccess(String signature) {
		"callSuccess("+ signature.selector +")"
	}
	
	def callTime(String signature) {
		"callTime("+ signature.selector +")"
	}
	
	def callCaller(String signature) {
		"callCaller("+ signature.selector +")"
	}
	
	def selector(String signature) {
		"this."+ signature + ".selector"
	}
	
	def clauseFulfilledTime(Clause clause) {
		"clauseFulfilledTime(\"" + clause.name + "\")"
	}
	
	def hasTimeFrame(TemporalConstraint tc) {
		tc.timeframe !== null
	}
			
	def deriveConstraints(Clause c) {
		var constraints = newArrayList
		val party = c.actor.party
		val tc = c.constraint.temporal
		val gc = c.constraint.general
		if (party.name != "anyone") {
			if(party.inferType.conformsToMap)
				constraints.add(party.name + ".contains(msg.sender)" -> "Caller not authorized")
			else
			constraints.add(callerCheck(party.name) -> "Caller not authorized")
		}
			
		if (tc !== null) {
			val ref = tc.reference
			if (ref instanceof Expression) {
				if (tc.timeframe === null)
					constraints.add(temporalCheck(tc.precedence, ref.compile, "0", false) -> temporalCheckReason(tc))
				else
					constraints.add(temporalCheck(tc.precedence, ref.compile, tc.timeframe.window.compile, tc.hasTimeFrame) -> temporalCheckReason(tc))
			}
			else if (ref instanceof ClauseQuery) {
				if (ref.status.equals(ClauseStatus.FAILED) || tc.precedence.equals(TemporalPrecedence.BEFORE))
					constraints.add(conditionalCheck("!(" + ref.clause.action.compoundAction.compile +")") -> "Clause " + ref.clause.name + " was fulfilled")
				else
					constraints.add(conditionalCheck(ref.clause.action.compoundAction.compile) -> "Clause " + ref.clause.name + " not fulfilled")	
				
				// TODO: temporal for failed case
				if (tc.timeframe === null)
					constraints.add(temporalCheck(tc.precedence, clauseFulfilledTime(ref.clause), "0", false) -> temporalCheckReason(tc))
				else
					constraints.add(temporalCheck(tc.precedence, clauseFulfilledTime(ref.clause), tc.timeframe.window.compile, tc.hasTimeFrame) -> temporalCheckReason(tc))
			}
			else if (ref instanceof EventQuery) {
				if (tc.precedence.equals(TemporalPrecedence.AFTER))
					constraints.add(conditionalCheck(callSuccess(ref.event.name.concat("Event"))) -> "Event " + ref.event.name + " did not occur")
				if (tc.precedence.equals(TemporalPrecedence.BEFORE))
					constraints.add(conditionalCheck("!" + callSuccess(ref.event.name.concat("Event"))) -> "Event " + ref.event.name + " already occurred")

				if (tc.timeframe === null)
					constraints.add(temporalCheck(tc.precedence, callTime(ref.event.name.concat("Event")), "0", false) -> temporalCheckReason(tc))
				else
					constraints.add(temporalCheck(tc.precedence, callTime(ref.event.name.concat("Event")), tc.timeframe.window.compile, tc.hasTimeFrame) -> temporalCheckReason(tc))
			}
			else if (ref instanceof ActionQuery) {
				val actionParty = interceptAttribute(ref.party, null) ?: ref.party.name
				if (tc.precedence.equals(TemporalPrecedence.AFTER)) {
					if (ref.party.name != "anyone")
						constraints.add(conditionalCheck(callCaller(ref.action.name) + " == " + actionParty + ".id") -> ref.party.inferType.name + " " + ref.party.name + " did not " + ref.action.name)
					constraints.add(conditionalCheck(callSuccess(ref.action.name)) -> "Action " + ref.action.name + " did not occur")
				}
				if (tc.precedence.equals(TemporalPrecedence.BEFORE)) {
					if (ref.party.name != "anyone")
						constraints.add(conditionalCheck(callCaller(ref.action.name) + " != " + actionParty + ".id") -> ref.party.inferType.name + " " + ref.party.name + " did " + ref.action.name)
					constraints.add(conditionalCheck("!" + callSuccess(ref.action.name)) -> "Action " + ref.action.name + " already occurred")
				}
				
				if (tc.timeframe === null)
					constraints.add(temporalCheck(tc.precedence, callTime(ref.action.name), "0", false) -> temporalCheckReason(tc))
				else
					constraints.add(temporalCheck(tc.precedence, callTime(ref.action.name), tc.timeframe.window.compile, tc.hasTimeFrame) -> temporalCheckReason(tc))
			}	
		}
		if (gc !== null)
			constraints.add(conditionalCheck(gc.expression.compile) -> "Given condition(s) not met")
		constraints
	}

	def compileEventFunctions(CmlClass c) '''
		«FOR e : c.attributes.filter[inferType.mapsToEvent] SEPARATOR "\n" AFTER "\n"»
			«e.compileEventAsFunction»
		«ENDFOR»
	'''
	
	def compileStaticFunctions(CmlClass c) '''
		«FOR o : c.staticOperations SEPARATOR "\n" AFTER "\n"»
			«o.compile(o.deriveAnnotations, newLinkedHashMap)»
		«ENDFOR»
	'''

	def compileFunctions(CmlClass c) '''
		«FOR cl : c.clauses»
			«FOR aa : cl.action.compoundAction.eAllOfType(AtomicAction) SEPARATOR "\n" AFTER "\n"»
				// @notice function for clause «cl.name»
				«aa.operation.compile(aa.operation.deriveAnnotations, cl.deriveModifiers)»
			«ENDFOR»
		«ENDFOR»
	'''

	def String compileEnums(CmlClass c) '''
		«FOR a : c.gatherEnums BEFORE "/*\n * Enums\n */\n" SEPARATOR "" AFTER "\n"»
			«a.compileEnum»
		«ENDFOR»
	'''
	
	def String compileStructs(CmlClass c) '''
		«FOR entry : c.gatherStructs BEFORE "/*\n * Structs\n */\n" SEPARATOR "\n" AFTER "\n"»
			«entry.compile»
		«ENDFOR»
	'''
	
	def Set<CmlClass> gatherEnums(CmlClass c) {
		val set = new LinkedHashSet<CmlClass>
		set.addAll(c.traverseForNamedElements.map[inferType].filter[mapsToEnum])
		for (entry : c.traverseForNamedElements.map[inferType].filter[mapsToStruct])
			set.addAll(entry.traverseForEnums)
		set
	}

	def Set<CmlClass> traverseForEnums(CmlClass c) {
		val set = new LinkedHashSet<CmlClass>
		for (class : c.attributes.map[inferType]) {
			if (class.mapsToEnum)
				set.add(class)
			if (!class.equals(c))
				set.addAll(traverseForEnums(class))
		}
		set
	}

	def Set<CmlClass> gatherStructs(CmlClass c) {
		val set = new LinkedHashSet<CmlClass>
		val elements = c.traverseForNamedElements.map[inferType].filter[mapsToStruct]
		set.addAll(elements)
		for (ne : c.traverseForNamedElements) {
			if (ne.inferType.conformsToArray || ne.inferType.conformsToMap) {
				var Pair<CmlClass, CmlClass> rslt = null
				if (ne instanceof Attribute)
					rslt = ne.type.resolveKeyValue
				if (ne instanceof Operation)
					rslt = ne.type.resolveKeyValue
				if (ne instanceof VariableDeclaration)
					rslt = ne.type.resolveKeyValue

				if (rslt.key !== null && rslt.key.mapsToStruct)
					set.add(rslt.key)
				if (rslt.value !== null && rslt.value.mapsToStruct)
					set.add(rslt.value)
			}
		}
		for (entry : elements)
			set.addAll(entry.traverseForStructs)
		set
	}

	def Set<CmlClass> traverseForStructs(CmlClass c) {
		val set = new LinkedHashSet<CmlClass>
		for (class : c.attributes.filter[inferType.mapsToStruct].map[inferType]) {
			set.add(class)
			if (!class.equals(c))
				set.addAll(traverseForStructs(class))
		}
		set
	}

	def Set<NamedElement> traverseForNamedElements(Operation o) {
		val set = new LinkedHashSet<NamedElement>
		set.addAll(o.references)
		set.addAll(o.variableDeclarations)
		for (op : o.referencedOperations) {
			if (op !== o)
				set.addAll(op.traverseForNamedElements)
		}
		set
	}

	def Set<NamedElement> traverseForNamedElements(CmlClass c) {
		val set = new LinkedHashSet<NamedElement>
		set.addAll(c.attributes)
		set.addAll(c.operations)
		set.addAll(c.operations.map[params].flatten)
		for (o : c.operations) {
			set.addAll(o.traverseForNamedElements)
		}
		set
	}

	def <T extends EObject> getAllContentsOfType(CmlProgram c, Class<T> type) {
		val Set<T> result = new LinkedHashSet<T>
		val sources = newLinkedList
		sources.add(c)
		sources.addAll(c.gatherImports)

		for (s : sources) {
			result.addAll(EcoreUtil2.getAllContentsOfType(s, type))
		}
		result
	}

	def Set<Operation> staticOperations(CmlClass c) {
		c.traverseForNamedElements.filter(Operation).filter[static && !containedInMainLib].toSet
	}

	def Set<Attribute> staticAttributes(CmlClass c) {
		c.traverseForNamedElements.filter(Attribute).filter[static].toSet
	}

	def mapsToStruct(CmlClass c) {
		!c.conformsToLibraryType && !c.conformsToToken && !c.mapsToEnum && !c.conformsToTokenTransaction && !c.conformsToMap && !c.conformsToArray && !c.conformsToVoid && !c.conformsToUndefined
	}

	def mapsToEnum(CmlClass c) {
		c.conformsToEnum || c.subclassOfEnum
	}

	def mapsToEvent(CmlClass c) {
		c.conformsToEvent || c.subclassOfEvent
	}
	
	def compileAttributes(CmlClass c) '''
		«FOR a : c.staticAttributes»
			«a.compile»;
		«ENDFOR»
		«FOR a : c.attributes.filter[!inferType.mapsToEnum]»
			«IF a.inferType.conformsToMap»
				«val name = a.compileMapImplName »
				using «name» for «name».Data;
				«name».Data internal «a.name»;
			«ELSE»
				«a.compile»;
			«ENDIF»
		«ENDFOR»
	'''

	def compileEvents(CmlClass c) '''
		«FOR e : c.attributes.filter[inferType.mapsToEvent] BEFORE "/*\n * Events\n */\n" AFTER "\n"»
			event «e.name.toFirstUpper»Event(«e.inferType.name» «e.name»);
		«ENDFOR»
	'''

	def compileConstructor(CmlClass c) {
		val initOperation = c.operations.findFirst[name == "init"]
		if (initOperation !== null)
			initOperation.compileInitConstructor
		else
			c.compileStandardConstructor
	}

	def compileInitConstructor(Operation o) '''	
		constructor(«o.params.compileOpParams») «FOR a : o.deriveAnnotations SEPARATOR ' '»«a»«ENDFOR» {
			«FOR s : o.body?.statements ?: emptyList»
				«compileStatement(s)»
			«ENDFOR»
			_contractStart = now;
		}
	'''

	def compileStandardConstructor(CmlClass c) '''
		constructor() public {
			_contractStart = now;
		}
    '''

	def compileStates(CmlClass c) '''
		«FOR s : c.clauses.indexed»
			bytes32 constant STATE«s.key» = "«s.value.name»";
		«ENDFOR»
		bytes32[] states = [«FOR s : c.clauses.indexed SEPARATOR ", "»STATE«s.key»«ENDFOR»];
		
	'''
	
	def String compile(CompoundAction ca) {
		switch (ca) {
			XorCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				left + " != " + right
			}
			OrCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				left + " || " + right
			}
			AndCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				left + " && " + right
			}
			NestedCompoundAction: {
				"(" + ca.child.compile + ")"
			}
			AtomicAction:
				callSuccess(ca.operation.name)
		}
	}
	
	def transformOpPArams(List<Attribute> attributes) {
		val attributesCopy = attributes.copyAll

		for(val iter = attributesCopy.iterator; iter.hasNext();) {
			val attribute = iter.next()
			if(attribute.inferType.conformsToTokenTransaction)
				iter.remove()
		}
		attributesCopy
	}
	
	def compileOpParams(List<Attribute> attributes) '''
		«FOR a : attributes.transformOpPArams SEPARATOR ', '»«a.compileOpParam»«ENDFOR»'''

	def compileOpParam(Attribute a) {
		interceptAttribute(a, null) ?: '''«a.type.compile»«IF a.inferType.requiresDataLocation» memory«ENDIF» «a.name»'''
	}
	
	def compile(Attribute a) {
		interceptAttribute(a, null) ?: '''«a.type.compile»«IF a.constant» constant«ENDIF» «a.name»«IF a.expression !== null» = «a.expression.compile»«ENDIF»'''
	}
		
	def compile(CmlClass c) '''
		struct «c.name.toFirstUpper» {
			«FOR a : c.classHierarchyAttributes.values»
				«val value = a.compile»
				«IF (!value.nullOrEmpty)»«(value + ";")»«ENDIF»
	   		«ENDFOR»
		}
	'''
	
	def compile(Operation o, List<String> annotations, LinkedHashMap<String, List<String>> modifiers) '''	
		function «o.name»(«o.params.compileOpParams») «FOR a : annotations SEPARATOR ' '»«a»«ENDFOR»
			«FOR m : modifiers.entrySet SEPARATOR ' '»
				«m.key»(«m.value.join(", ")»)
			«ENDFOR»
			«IF o.type !== null»returns («o.type.compile»«IF o.inferType.requiresDataLocation» memory«ENDIF»)«ENDIF»
		{
			«FOR s : o.body?.statements ?: emptyList»
				«compileStatement(s)»
			«ENDFOR»
		}
	'''
	
	def payable(Operation o) {
		o.eAllOfType(Statement).filter(FeatureSelectionExpression)?.filter[opCall && feature instanceof Operation]?.map[feature]?.
			findFirst[containingClass.conformsToParty && name == "deposit"] !== null
	}
	
//	def modifiesStateAttributes(Operation o) {
//		!o.eAllOfType(AssignmentExpression).map[left].filter(ReferenceExpression).map[symbol].filter(Attribute).filter[!static].empty
//	}
	
	def List<String> deriveAnnotations(Operation o) {
		var list = newArrayList
		list.add("public")
		if (o.payable)
			list.add("payable")
		else if (o.static) 
			list.add("pure")
//		else if (!o.modifiesStateAttributes) // TODO
//			list.add("view")
		list
	}

	def deriveModifiers(Clause c) {
		var modifiers = new LinkedHashMap<String, List<String>>()
		var list = newArrayList
		list.add("\""+c.name+"\"")
		modifiers.put("checkAllowed", list)
		modifiers
	}
	
	def compileBlock(Block block) '''
		{	
			«FOR s : block.statements»
				«s.compileStatement»
			«ENDFOR»
		}
	'''
	
	def compileVarAssignment(Expression exp) {
		if (exp instanceof NewExpression) {
			if (exp.args.size == 0) {
				return false
			}
		}
		return true
	}
	
	def String compileStatement(Statement s) {
		switch (s) {
			VariableDeclaration: '''«s.type.compile»«IF s.type.inferType.requiresDataLocation» «s.expression.deriveDataLocation»«ENDIF» «s.name»«IF compileVarAssignment(s.expression)» = «s.expression.compile»«ENDIF»;'''
			ReturnStatement:
				"return (" + s.expression.compile + ");"
			IfStatement: '''
				if («s.condition.compile»)
				«s.thenBlock.compileBlock»
				«IF s.elseBlock !== null»
					else
					«s.elseBlock.compileBlock»
				«ENDIF»
			'''
			SwitchStatement: '''
				«FOR c : s.cases.indexed»
					«IF c.key == 0»if «ELSE»else if«ENDIF»(«s.declaration.compile» == «c.value.^case.compile»)
					«c.value.thenBlock.compileBlock»
				«ENDFOR»
				«IF s.^default»
					else
					«s.defaultBlock.compileBlock»
				«ENDIF»
			'''
			DoWhileStatement: '''
				do
				«s.block.compileBlock»
				while («s.condition.compile»);
			'''
			WhileStatement: '''
				while («s.condition.compile»)
				«s.block.compileBlock»
			'''
			ForBasicStatement: '''
				for («s.declaration.compileStatement» «s.condition.compile»; «s.progression.compile»)
				«s.block.compileBlock»
			'''
			ForLoopStatement: '''
				«IF (s.forExpression.typeFor as CmlClass).conformsToArray»«s.compileForLoopForArray»«ELSE»«s.compileForLoopForMap»«ENDIF»
			'''
			default: {
				val statement = (s as Expression).compile
				if (!statement.nullOrEmpty) (statement + ";") else ""
			}
		}
	}
	
	def compileForLoopForArray(ForLoopStatement s) '''
		for (uint i = 0; i < «s.forExpression.compile».length; i++)
		{
			«val type = (((s.forExpression as ReferenceExpression).reference as Attribute).type as GenericArrayTypeReference).componentType»
			«type.compile» «s.declaration.name» = «s.forExpression.compile»[i];
			«FOR bs : s.block.statements»
				«bs.compileStatement»
			«ENDFOR»
		}
	'''
	
	def compileForLoopForMap(ForLoopStatement s) '''
		for (uint i = 0; i < «s.forExpression.compile».size(); i++)
		{
			«val type = (((s.forExpression as ReferenceExpression).reference as Attribute).type as GenericArrayTypeReference).componentType»
			«type.compile»«IF type.inferType.requiresDataLocation» storage«ENDIF» «s.declaration.name» = «s.forExpression.compile».getEntry(i);
			«FOR bs : s.block.statements»
				«bs.compileStatement»
			«ENDFOR»
		}
	'''

	def compileEventAsFunction(Attribute a) '''
		// @notice trigger event «a.inferType.name»
		function «a.name.toFirstLower»Event(«a.inferType.name» memory _«a.name») public postCall
		{
			«a.name» = _«a.name»;
			emit «a.name.toFirstUpper»Event(«a.name»);
		}
	'''

	def compileEnum(CmlClass c) '''
		enum «c.name.toFirstUpper» { «FOR e : c.enumElements SEPARATOR ', '»«e.name»«ENDFOR» } «c.name.toFirstUpper» «c.name.toFirstLower»;
	'''

	def String compile(TypeReference tr) {
		switch(tr) {
			ParameterizedTypeReference : (tr.type.inferType as Type).compile
			GenericArrayTypeReference : tr.componentType.compile + "[]"
		}
	}
	
	def String compile(Type t) {
		switch (t) {
			CmlClass:
				switch (t) {
					case t == GLOBAL_ID_TYPE: "address"
					case t.conformsToInteger: "uint" // "int"
					case t.conformsToBoolean: "bool"
					case t.conformsToString: "bytes32"
					case t.conformsToReal: if (fixedPointArithmetic) "uint" else "ufixed" //"fixed"
					case t.conformsToDateTime: "uint"
					case t.conformsToDuration: "uint"
					case t.conformsToNumber: "uint"
					case t.mapsToStruct,
					case t.mapsToEnum: detachModel ? MODEL_NAME + "." + t.name : t.name
					default: t.name
				}
		}
	}
		
	def compileMapLib(String libName, Type keyType, Type valueType) {
		var key = keyType.compile
		val value = valueType.compile
		'''
		pragma solidity >=0.4.22 <0.7.0;
		pragma experimental ABIEncoderV2;
		
		import "./CLL«key.toFirstUpper».sol";
		«IF (valueType as CmlClass).mapsToStruct»import "./«MODEL_NAME».sol";«ENDIF»
		
		library «libName» {
		
			struct Data {
			    mapping(«key» => «value») map;
		        CLL«key.toFirstUpper».CLL mapIdList;
			}
			
			using CLL«key.toFirstUpper» for CLL«key.toFirstUpper».CLL;
		    
		    function size(Data storage self) public view returns (uint) {
		        return self.mapIdList.sizeOf();
		    }
		
		    function add(Data storage self, «key» _key, «value»«IF valueType.requiresDataLocation» memory«ENDIF» _value) public {
		        self.map[_key] = _value;
		        self.mapIdList.push(_key, true);
		    }
		
		    function remove(Data storage self, «key» _key) public {
		        if(self.mapIdList.nodeExists(_key)) {
		            delete self.map[_key];
		            self.mapIdList.remove(_key);
		        }
		    }
		
		    function contains(Data storage self, «key» _key) public view returns (bool) {
		        return self.mapIdList.nodeExists(_key);
		    }
		    
		    function get(Data storage self, «key» _key) public view returns («value»«IF valueType.requiresDataLocation» storage«ENDIF») {
		        return self.map[_key];
		    }
		    
		    function getEntry(Data storage self, uint _index) public view returns («value»«IF valueType.requiresDataLocation» storage«ENDIF») {
		        return self.map[self.mapIdList.nodeAt(_index)];
		    }
		    
		    function isEmpty(Data storage self) public view returns (bool) {
		        return !self.mapIdList.exists();
		    }
		    
		    function getKeys(Data storage self) public view returns («key»[] memory) {
		        return self.mapIdList.keys();
		    }
		    
		    function clear(Data storage self) public {
		        «key»[] memory arr = getKeys(self);
		        for (uint i = 0; i < arr.length; i++) {
		            delete self.map[arr[i]];
		            remove(self, arr[i]);
		        }
		    }
		}
	'''
	}
	
	def requiresDataLocation(Type t) {
		if(t instanceof CmlClass)
			if(t.mapsToStruct || t.conformsToArray) 
				return true
		false
	}
	
	def deriveDataLocation(Expression e) {
		if(e instanceof ArrayAccessExpression)
			return "storage"
		return "memory"
	}
	
	def compileCLLLib(String libName, Type type) '''
		«getResource("cml/CLL.sol").replace("$LIB_NAME$", libName).replace("$TYPE$", type.compile)»'''

	def retrieveImport(Iterable<CmlProgram> resources, Import i) {
		if (i.importedNamespace !== CmlLib::LIB_PACKAGE)
			resources.findFirst[name == i.copy.importedNamespace.replace(".*", "")]
	}

	def List<CmlProgram> gatherImports(CmlProgram program) {
		var list = new LinkedList<CmlProgram>
		for (i : program.imports) {
			val import = this.allResources.retrieveImport(i)
			list.add(import)
			list.addAll(gatherImports(import))	// recursive
		}
		list
	}

	def String compile(Expression exp) {
		switch (exp) {
			AssignmentExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				switch (exp.op) {
					case '=': '''«left» = «right»'''
					case '+=': '''«left» += «right»'''
					case '-=': '''«left» -= «right»'''
					default: ""
				}
			}
			OrExpression: '''«(exp.left.compile)» || «(exp.right.compile)»'''
			AndExpression: '''«(exp.left.compile)» && «(exp.right.compile)»'''
			EqualityExpression: {
				if (exp.op == '==')
					'''«(exp.left.compile)» == «(exp.right.compile)»'''
				else
					'''«(exp.left.compile)» != «(exp.right.compile)»'''
			}
			RelationalExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				switch (exp.op) {
					case '<': '''«left» < «right»'''
					case '>': '''«left» > «right»'''
					case '>=': '''«left» >= «right»'''
					case '<=': '''«left» <= «right»'''
					default: ""
				}
			}
			AdditiveExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				if (safeMath && !fixedPointArithmetic)
					switch (exp.op) {
						case '+': '''SafeMath.add(«(left)», «(right)»)'''
						case '-': '''SafeMath.sub(«(left)», «(right)»)'''
					}
				else if (fixedPointArithmetic) // fixedPointArithmetic uses safeMath ops per default 
					switch (exp.op) {
						case '+': '''FPMath.add(«(left)», «(right)»)'''
						case '-': '''FPMath.sub(«(left)», «(right)»)'''
					}	
				else
					switch (exp.op) {
						case '+': '''«(left)» + «(right)»'''
						case '-': '''«(left)» - «(right)»'''
					}
			}
			MultiplicativeExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				if (safeMath && !fixedPointArithmetic)
					switch (exp.op) {
						case '*': '''SafeMath.mul(«(left)», «(right)»)'''
						case '/': '''SafeMath.div(«(left)», «(right)»)'''
						case '%': '''SafeMath.mod(«(left)», «(right)»)'''
						case '**': '''«(left)» ** «(right)»''' // TODO
					}
				else if (fixedPointArithmetic) // fixedPointArithmetic uses safeMath ops per default 
					switch (exp.op) {
						case '*': '''FPMath.fpmul(«(left)», «(right)», «(fixedPointDecimals)»)'''
						case '/': '''FPMath.fpdiv(«(left)», «(right)», «(fixedPointDecimals)»)'''
						case '%': '''SafeMath.mod(«(left)», «(right)»)'''
						case '**': '''FPMath.fppow(«(left)», «(right)», «(fixedPointDecimals)»)'''
					}
				else
					switch (exp.op) {
						case '*': '''«left» * «right»'''
						case '/': '''«(left)» / «(right)»'''
						case '%': '''«(left)» % «(right)»'''
						case '**': '''«(left)» ** «(right)»'''
					}
			}
			UnaryExpression: {
				switch (exp.op) {
					case '+': ''' +«(exp.operand.compile)»'''
					case '-': ''' -«(exp.operand.compile)»'''
					case '!',
					case 'not': ''' !«(exp.operand.compile)»'''
				}
			}
			PostfixExpression: {
				if (exp.op == '++')
					'''«(exp.operand.compile)»++'''
				else
					'''«(exp.operand.compile)»--'''
			}
			CastedExpression: '''«exp.target.compile»'''
			NestedExpression: '''(«exp.child.compile»)'''
			RealLiteral:
				if (fixedPointArithmetic)
					'''«fixedPointRepresentation(exp.value)»'''
				else
					'''«exp.value»'''
			IntegerLiteral:
				if (fixedPointArithmetic)
					'''«fixedPointRepresentation(BigDecimal.valueOf(exp.value))»'''
				else
					'''«exp.value»'''
			BooleanLiteral: '''«exp.value»'''
			StringLiteral: '''"«exp.value»"'''
			SuperExpression: '''super'''
			ThisExpression: '''this''' // concept doesn't exist in the same manner in solidity
			DateTimeLiteral: '''«exp.compile»'''
			DurationLiteral: '''«exp.value» «exp.unit»'''
			ReferenceExpression: '''«exp.compile»'''
			FeatureSelectionExpression: '''«exp.compile»'''
			NewExpression: '''«exp.compile»'''
			NullLiteral: '''?'''
			ArrayAccessExpression: '''«exp.compile»'''
		}
	}
	
	def compile(ArrayAccessExpression aae) {
		val type = aae.array.typeFor
		if ((type as CmlClass).conformsToMap) {
			aae.array.compile + ".get(" + aae.indexes.get(0).compile + ")"
		} else {
			aae.array.compile + "[" + aae.indexes.get(0).compile + "]"
		}
	}
	
	def compile(NewExpression ne) {
		val type = ne.type.inferType
		if (type.mapsToStruct) {
			(detachModel ? MODEL_NAME + "." : "") + type.name + "(" + ne.args.map[compile].filterNull.filter[!it.empty].join(", ") + ")"
		}
	}
	
	def compile(DateTimeLiteral dtl) {
		Instant.parse(dtl.value + "T00:00:00.00Z").getEpochSecond();
	}

	def fixedPointRepresentation(BigDecimal b) {
		b.scaleByPowerOfTen(fixedPointDecimals).toString().replace("E+", "E")
	}
	
	def resolvePath(FeatureSelectionExpression fse) {
		val list = newLinkedList
		list.add(fse.feature)
		var current = fse.receiver
		while (current !== null) {
			if (current instanceof FeatureSelectionExpression) {
				list.add(current.feature)
				current = current.receiver
			} else if (current instanceof ReferenceExpression) {
				list.add(current.reference)
				current = null
			} else {
				current = null
			}
		}
		list
	}
	
	def resolvePath(Expression e) {
		if (e instanceof FeatureSelectionExpression) {
			e.resolvePath
		} else if (e instanceof ReferenceExpression) {
			#[e.reference]
		}
	}
 	
	def compile(FeatureSelectionExpression fse) {
		var String rslt

		if (!fse.opCall && fse.feature instanceof Attribute)
			rslt = interceptAttribute(fse.feature as Attribute, fse)

		if (fse.opCall && fse.feature instanceof Operation)
			rslt = interceptOperation(fse.feature as Operation, fse.args, fse.receiver)

		rslt ?: {
			val sb = new StringBuilder()
			sb.append(fse.receiver.compile)
			sb.append(".")
			sb.append(fse.feature.name)
			if (fse.opCall)
				sb.append("(" + fse.args.map[compile].join(", ") + ")")
			sb.toString
		}
	}

	def compile(ReferenceExpression re) {
		var String rslt

		if (!re.opCall && re.reference instanceof Attribute)
			rslt = interceptAttribute(re.reference as Attribute, re)

		if (re.opCall && re.reference instanceof Operation)
			rslt = interceptOperation(re.reference as Operation, re.args, re)

		if (re.opCall && re.reference instanceof CmlClass)
			rslt = interceptClass(re.reference as CmlClass, re.args, re)

		rslt ?: {
			val sb = new StringBuilder()
			if(detachModel && re.reference.inferType.mapsToEnum)
				sb.append(MODEL_NAME + ".")
			sb.append(re.reference.name)
			if (re.opCall)
				sb.append("(" + re.args.map[compile].join(", ") + ")")
			sb.toString
		}
	}

	def interceptClass(CmlClass c, List<Expression> args, ReferenceExpression re) {
		switch (c) {
			case c.conformsToError: {
				args.get(0).compile
			}
			/*case c.subclassOfParty: {
				val _args = args.copyAll
				_args.remove(1)
				re.reference.name + "(" + _args.map[compile].join(", ") + ")"
			}*/
		}
	}

	def interceptAttribute(Attribute a, Expression ref) {
		val c = a.containingClass
		if (c !== null) {
			if (c.conformsToContract) {
				switch (a.name) {
					case "contractStart": "_contractStart"
					case "caller": caller
				}
			} else if (c.conformsToAccount) {
				switch (a.name) {
					case "token": ""
					case "id": if (ref === null) "address payable id"
				}
			} else if (c.conformsToToken) {
				switch (a.name) {
					case "quantity": if (ref !== null) "address(this).balance"
				}
			} else if (c.conformsToTransaction) {
				switch (a.name) {
					case "sender": if (ref === null) "" else caller
				}
			} else if (c.conformsToTokenTransaction) {
				switch (a.name) {
					case "amount": if (ref === null) "" else "msg.value"
				}
			}
		}
	}
	
	def caller() {
		(detachModel ? MODEL_NAME + "." : "") + "Party(msg.sender)"
	}
		
	def interceptOperation(Operation o, List<Expression> args, Expression ref) {
		if (!o.static) {
			val c = o.containingClass
			val path = ref.resolvePath
			
			if (c.conformsToAccount) {
				switch (o.name) {
					case "isSet": ref.compile + ".id != address(0)"
				}
			} else if (c.conformsToParty) {
				switch (o.name) {
					case "deposit": ""
					case "withdraw": {
						if (pullPayment) {
							"_asyncTransfer(" + ref.compile + ".id , " + args.get(0).compile + ")"
						} else {
							ref.compile + ".id.transfer" + "(" + args.get(0).compile + ")"
						}
					}
				}
			} else if (c.conformsToContract) {
				switch (o.name) {
					case "transfer": {
						if (pullPayment) {
							"_asyncTransfer(" + args.get(0).compile + ".id , " + args.get(1).compile + ")"
						} else {
							args.get(0).compile + ".id.transfer" + "(" + args.get(1).compile + ")"
						}
					}
				}
			} else if (c.conformsToNumber) {
				switch (o.name) {
					case "toInteger": {
						if (path.get(0).inferType.conformsToInteger || path.get(0).inferType.conformsToNumber)
							ref.compile
						else if (path.get(0).inferType.conformsToReal)
							if(fixedPointArithmetic) "RealLib.toInteger(" + ref.compile + ", " +
								fixedPointDecimals + ")" else "??? Not yet implemented"
					}
					case "toReal": {
						if (path.get(0).inferType.conformsToInteger)
							if(fixedPointArithmetic) "IntLib.toReal(" + ref.compile +
								")" else "??? Not yet implemented"
						else if (path.get(0).inferType.conformsToReal || path.get(0).inferType.conformsToNumber)
							ref.compile
					}
				}
			} else if (c.conformsToInteger) {
				switch (o.name) {
					case "average": "IntLib.average(" + ref.compile + ", " + args.get(0).compile + ")"
					case "max": "IntLib.max(" + ref.compile + ", " + args.get(0).compile + ")"
					case "min": "IntLib.min(" + ref.compile + ", " + args.get(0).compile + ")"
				}
			} else if (c.conformsToReal) {
				switch (o.name) {
					case "max": "RealLib.max(" + ref.compile + ", " + args.get(0).compile + ")"
					case "min": "RealLib.min(" + ref.compile + ", " + args.get(0).compile + ")"
					case "sqrt": "RealLib.sqrt(" + ref.compile + ")"
					case "ceil": if (fixedPointArithmetic) "RealLib.ceil(" + ref.compile + ", " + fixedPointDecimals+ ")" else "??? Not yet implemented"
					case "floor": if (fixedPointArithmetic) "RealLib.floor(" + ref.compile + ", " + fixedPointDecimals+ ")" else "??? Not yet implemented"
				}
			} else if (c.conformsToDateTime) {
				switch (o.name) {
					case "isBefore": "DateTime.isBefore(" + ref.compile + ", " + args.get(0).compile + ")"
					case "isAfter": "DateTime.isAfter(" + ref.compile + ", " + args.get(0).compile + ")"
					case "second": "DateTime.getSecond(" + ref.compile + ")"
					case "minute": "DateTime.getMinute(" + ref.compile + ")"
					case "hour": "DateTime.getHour(" + ref.compile + ")"
					case "day": "DateTime.getDay(" + ref.compile + ")"
					case "week": "DateTime.getWeek(" + ref.compile + ")"
					case "equals": "DateTime.equals(" + ref.compile + ", " + args.get(0).compile + ")"
					case "addDuration": "DateTime.addDuration(" + ref.compile + ", " + args.get(0).compile + ")"
					case "subtractDuration": "DateTime.subtractDuration(" + ref.compile + ", " +
						args.get(0).compile + ")"
					case "durationBetween": "DateTime.durationBetween(" + ref.compile + ", " +
						args.get(0).compile + ")"
				}
			} else if (c.conformsToDuration) {
				switch (o.name) {
					case "toSeconds": ref.compile
					case "toMinutes": "DateTime.toMinutes(" + ref.compile + ")"
					case "toHours": "DateTime.toHours(" + ref.compile + ")"
					case "toDays": "DateTime.toDays(" + ref.compile + ")"
					case "toWeeks": "DateTime.toWeeks(" + ref.compile + ")"
					case "addDuration": "DateTime.addDuration(" + ref.compile + ", " + args.get(0).compile + ")"
					case "subtractDuration": "DateTime.subtractDuration(" + ref.compile + ", " +
						args.get(0).compile + ")"
				}
			} else if (c.conformsToArray) {
				switch (o.name) {
					case "size": ref.compile + ".length"
				}
			} else if (c.conformsToMap) {
				switch (o.name) {
					case "size": ref.compile + ".size()"
					case "isEmpty": ref.compile + ".isEmpty()"
					case "contains": ref.compile + ".contains(" + args.get(0).compile + ")"
					case "clear": ref.compile + ".clear()"
					case "add": ref.compile + ".add(" + args.get(0).compile + "." + (args.get(0).typeFor as CmlClass).resolveIdentifierName + ", " + args.get(0).compile + ")"
					case "rmv": ref.compile + ".remove(" + args.get(0).compile + ")"
					case "get": ref.compile + ".get(" + args.get(0).compile + ")"
					case "getEntry": ref.compile + ".getEntry(" + args.get(0).compile + ")"
				}
			}	
		} else {
			if (o.containedInMainLib) {
				switch (o.name) {
					case "ensure": "require(" + args.get(0).compile + ", " + args.get(1).compile + ")"
				}

			}
		}
	}
		
}
