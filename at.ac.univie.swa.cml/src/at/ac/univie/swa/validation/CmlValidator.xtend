/*
 * generated by Xtext 2.16.0
 */
package at.ac.univie.swa.validation

import at.ac.univie.swa.CmlModelUtil
import at.ac.univie.swa.cml.Attribute
import at.ac.univie.swa.cml.Block
import at.ac.univie.swa.cml.Class
import at.ac.univie.swa.cml.CmlPackage
import at.ac.univie.swa.cml.CmlProgram
import at.ac.univie.swa.cml.Expression
import at.ac.univie.swa.cml.MemberSelection
import at.ac.univie.swa.cml.NamedElement
import at.ac.univie.swa.cml.Operation
import at.ac.univie.swa.cml.Return
import at.ac.univie.swa.cml.VariableDeclaration
import at.ac.univie.swa.scoping.CmlIndex
import at.ac.univie.swa.typing.CmlTypeConformance
import at.ac.univie.swa.typing.CmlTypeProvider
import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import java.util.ArrayList
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType

import static extension org.eclipse.xtext.EcoreUtil2.*
import at.ac.univie.swa.cml.SuperExpression

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CmlValidator extends AbstractCmlValidator {
	
	@Inject extension IQualifiedNameProvider
	@Inject extension CmlModelUtil
	@Inject extension CmlTypeProvider
	@Inject extension CmlTypeConformance
	@Inject extension CmlIndex
	
	protected static val ISSUE_CODE_PREFIX = "cml.lang."
	public static val HIERARCHY_CYCLE = ISSUE_CODE_PREFIX + "HierarchyCycle"
	public static val FIELD_SELECTION_ON_METHOD = ISSUE_CODE_PREFIX + "FieldSelectionOnMethod"
	public static val METHOD_INVOCATION_ON_FIELD = ISSUE_CODE_PREFIX + "MethodInvocationOnField"
	public static val UNREACHABLE_CODE = ISSUE_CODE_PREFIX + "UnreachableCode"
	public static val MISSING_FINAL_RETURN = ISSUE_CODE_PREFIX + "MissingFinalReturn"
	public static val DUPLICATE_ELEMENT = ISSUE_CODE_PREFIX + "DuplicateElement"
	public static val INCOMPATIBLE_TYPES = ISSUE_CODE_PREFIX + "IncompatibleTypes"
	public static val INVALID_ARGS = ISSUE_CODE_PREFIX + "InvalidArgs"
	public static val WRONG_METHOD_OVERRIDE = ISSUE_CODE_PREFIX + "WrongMethodOverride"
	public static val MEMBER_NOT_ACCESSIBLE = ISSUE_CODE_PREFIX + "MemberNotAccessible"
	public static val DUPLICATE_CLASS = ISSUE_CODE_PREFIX + "DuplicateClass"
	public static val WRONG_SUPER_USAGE = ISSUE_CODE_PREFIX + "WrongSuperUsage"
	public static val REDUCED_ACCESSIBILITY = ISSUE_CODE_PREFIX + "ReducedAccessibility"
	public static val OPPOSITE_INCONSISTENCY = ISSUE_CODE_PREFIX + "OppositeInconsistency"
	public static val MISSING_IDENTITY_DEFINITION = ISSUE_CODE_PREFIX + "MissingIdentityDefinition"
	
	@Check
    def void checkNameStartsWithCapital(Class c) {
        if (!Character.isUpperCase(c.name.charAt(0))) {
            warning("Name should start with a capital", 
                CmlPackage.Literals.NAMED_ELEMENT__NAME)
        }
    }

	@Check 
	def void checkClassHierarchy(Class c) {
		if (c.classHierarchy.contains(c)) {
			error("Cycle in hierarchy of Class '" + c.name + "'",
				CmlPackage::eINSTANCE.class_Superclass,
				HIERARCHY_CYCLE,
				c.superclass.name)
		}
	}
	
	@Check 
	def void checkSuperclass(Class c) {
		if (c.kind != c.superclass.kind) {
			error("'" + c.name + "' must extend '" + c.kind + "'" ,
				CmlPackage::eINSTANCE.class_Superclass,
				INCOMPATIBLE_TYPES,
				c.superclass.name)
		}
	}
	
	@Check 
	def void checkIdentityDefinition(Class c) {
		if ((c.kind.equals("party") || c.kind.equals("asset")) && c.id === null && !c.isAbstract && !c.classHierarchy.exists[id !== null]) {
			error("'" + c.name + "' is not abstract. It must define an identifying attribute.",
				null,
				MISSING_IDENTITY_DEFINITION,
				c.name)
		}
	}

	@Check 
	def void checkNoDuplicateClasses(CmlProgram cmlp) {
		checkNoDuplicateElements(cmlp.classes, "class")
	}

	@Check 
	def void checkNoDuplicateFeatures(Class c) {
		val attributes = new ArrayList(c.classHierarchyAttributes.values);
		attributes.addAll(c.attributes)
		checkNoDuplicateElements(attributes, "attribute")
		checkNoDuplicateElements(c.operations, "operation")
		//checkNoDuplicateElements(c.clauses, "clause")
		//checkNoDuplicateElements(c.enumElements, "enumeration literal")
	}
	
	@Check 
	def void checkNoDuplicateSymbols(Operation o) {
		checkNoDuplicateElements(o.params, "parameter")
		checkNoDuplicateElements(o.body.getAllContentsOfType(VariableDeclaration), "variable")
	}
	
	// perform this check only on file save
	@Check(CheckType.NORMAL)
	def checkDuplicateClassesInFiles(CmlProgram p) {
		val externalClasses = p.getVisibleExternalClassesDescriptions
		for (c : p.classes) {
			val className = c.fullyQualifiedName
			if (externalClasses.containsKey(className)) {
				error("The type " + c.name + " is already defined", c, CmlPackage.eINSTANCE.namedElement_Name,
					DUPLICATE_CLASS)
			}
		}
	}
	
	/*
	@Check
	def void checkCorrectPropertyType(Feature feature){
		switch(feature){
			Attribute: if(!(feature.typeDef.type.kind != null || feature.typeDef.type.ref instanceof Enumeration))
							error("Wrong type for Attribute '" + feature.name + "'. Should be an enumeration or a primitive type",
								CmlPackage::eINSTANCE.feature_Name,
								WRONG_TYPE)
			Reference: if(!(feature.typeDef.type.kind == null && feature.typeDef.type.ref instanceof Class))
							error("Wrong type for Reference '" + feature.name + "'. Should be a Class",
								CmlPackage::eINSTANCE.feature_Name,
								WRONG_TYPE)
		}
	}*/
	
	@Check
	def void checkMemberSelection(MemberSelection mfc) {
		val member = mfc.member

		if (member instanceof Attribute && mfc.methodinvocation)
			error(
				'''Method invocation on a field''', CmlPackage.eINSTANCE.memberSelection_Methodinvocation,
				METHOD_INVOCATION_ON_FIELD)
		else if (member instanceof Operation && !mfc.methodinvocation)
			error(
				'''Field selection on a method''',
				CmlPackage.eINSTANCE.memberSelection_Member,
				FIELD_SELECTION_ON_METHOD
			)
	}
	
	@Check
	def void checkUnreachableCode(Block block) {
		val statements = block.statements
		for (var i = 0; i < statements.length - 1; i++) {
			if (statements.get(i) instanceof Return) {
				error("Unreachable code", statements.get(i + 1), null, UNREACHABLE_CODE)
				return
			}
		}
	}

	@Check
	def void checkMethodEndsWithReturn(Operation o) {
		if (o.returnStatement === null && !o.type.conformsToVoid) {
			error("Method must end with a return statement", CmlPackage.eINSTANCE.operation_Body, MISSING_FINAL_RETURN)
		}
	}
	
	@Check
	def void checkCorrectReturnUse(Return stmnt){
		val returntype = stmnt.containingOperation.type
		switch(returntype){
//			VoidType:
//				if(stmnt.expression !== null)
//					error("Return statement should be empty within void return type operation '" + stmnt.containingOperation.name + "'",
//						CmlPackage::eINSTANCE.return_Expression,
//						INCOMPATIBLE_TYPES) 
			default:
				if(stmnt.expression === null && returntype !== null)
					error("Return statement should not be empty within operation '" + stmnt.containingOperation.name + "'",
						null,
						INCOMPATIBLE_TYPES)	
		}
	}

	@Check
	def void checkSuper(SuperExpression s) {
		if (s.eContainingFeature != CmlPackage.eINSTANCE.memberSelection_Receiver)
			error("'super' can be used only as member selection receiver", null, WRONG_SUPER_USAGE)
	}
	
	@Check
	def void checkConformance(Expression exp) {
		val actualType = exp.typeFor
		val expectedType = exp.expectedType
		//println("checkConformance: " + exp.class.simpleName)
		//println("checkConformance: " + actualType.typeName + " : " + expectedType.typeName)
		if (expectedType === null || actualType === null)
			return; // nothing to check
		if (!actualType.isConformant(expectedType)) {
			error("Incompatible types. Expected '" + expectedType + "' but was '" + actualType + "'",
				null, INCOMPATIBLE_TYPES);
		}
	}

	@Check def void checkMethodInvocationArguments(MemberSelection mfc) {
		val method = mfc.member
		if (method instanceof Operation) {
			if (method.params.size != mfc.args.size) {
				error("Invalid number of arguments: expected " + method.params.size + " but was " + mfc.args.size,
					CmlPackage.eINSTANCE.memberSelection_Member, INVALID_ARGS)
			}
		}
	}
	
	/* 
	@Check
	def void checkNoDeclarationOutsideOfOperationBlock(VariableDeclaration decl){
		if(decl.containingBlock instanceof ConditionalBlock)
			error("Variable declaration allowed only in operations' top-level block", 
				CmlPackage::eINSTANCE.local_Name, 
				DECLARATION_WITHIN_BLOCK)
	}
	
	
	@Check
	def void checkCollectionLiteralWithSameType(CollectionLiteral lit){
	}*/
	
	/* 
	@Check
	def void checkAttribute(Attribute a) {
		if ((a.isReference && a.type instanceof Primitive && (a.type.inferType.isAbstract || (!a.type.inferType.subclassOfParty && !a.type.inferType.subclassOfCommodity)))  ||
			(a.isReference && a.type instanceof Primitive == false && (a.type.inferType.typeVar.isAbstract || (!a.type.inferType.typeVar.subclassOfParty && !a.type.inferType.typeVar.subclassOfCommodity))))
		{
			error("Relationship '" + a.name + "' cannot be to type '" + a.type.inferType.typeName + "'",  null,
				OPPOSITE_INCONSISTENCY)
		}
	}*/

	def private void checkNoDuplicateElements(Iterable<? extends NamedElement> elements, String desc) {
		val multiMap = HashMultimap.create()

		for (e : elements)
			multiMap.put(e.name, e)

		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					error("Duplicate " + desc + " '" + d.name + "'", d, CmlPackage.eINSTANCE.namedElement_Name,
						DUPLICATE_ELEMENT)
			}
		}
	}
	
}
