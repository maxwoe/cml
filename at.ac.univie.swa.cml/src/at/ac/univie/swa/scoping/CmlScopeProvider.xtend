/*
 * generated by Xtext 2.16.0
 */
package at.ac.univie.swa.scoping

import at.ac.univie.swa.cml.Class
import at.ac.univie.swa.cml.CmlPackage
import at.ac.univie.swa.cml.Enumeration
import at.ac.univie.swa.cml.EnumerationLiteral
import at.ac.univie.swa.cml.MemberSelection
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import at.ac.univie.swa.typing.CmlTypeProvider

import static extension at.ac.univie.swa.util.CmlModelUtil.*
import javax.inject.Inject
import at.ac.univie.swa.lib.CmlLib

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CmlScopeProvider extends AbstractCmlScopeProvider {

//	// private static final Logger logger = Logger.getLogger(CmlScopeProvider.getName());
//	// @Inject extension CmlExtensions
//	override getScope(EObject context, EReference reference) {
//
//		println(context.class);
//		
//		if (reference == CmlPackage.Literals.ATOMIC_ACTION__ACTION) {
//			if (context instanceof AtomicAction) {
////				val clause = EcoreUtil2.getContainerOfType(context, Clause)
////				if (clause !== null && clause.actor !== null && clause.actor.party !== null) {
////					val allActions = EcoreUtil2.getAllContentsOfType(clause.actor.party, Action)
////					return Scopes.scopeFor(allActions)
////					//return Scopes.scopeFor(allActions.filter[context.args.size == args.size])
////				}
//				val clause = EcoreUtil2.getContainerOfType(context, Clause)
//				if (clause?.actor?.party?.type !== null) {
//					val allActions = EcoreUtil2.getAllContentsOfType((clause.actor.party.type as ComplexType).ref, Action)
//					return Scopes.scopeFor(allActions)
//					//return Scopes.scopeFor(allActions.filter[context.args.size == args.size])
//				}
//			}
//		}
//		
//		if (reference == CmlPackage.Literals.ATTRIBUTE_REFERENCE__REF) {
//			println("ATTRIBUTE_REFERENCE__REF ctx: " + context)
//		}
//		
//		if (reference == CmlPackage.Literals.MEMBER_SELECTION__MEMBER) {
//			println("ctx: " + context)
//			
//			
//
//			if (context instanceof AttributeReference) {
//				val head = context.ref
//				println("AttributeReference rec: " + head)
//				
//				}
//				
//			if (context instanceof MemberSelection) {
//				val head = context.receiver
//				println("MemberFeatureCall rec: " + head)
//				
//				var parentScope = IScope::NULLSCOPE
//				var type = context.receiver.
//				if (type == null || type.isPrimitiveType)
//					return parentScope
//				if (type instanceof Class) {
//					val features = (type as Class).selectedFeatures(sel)
//					for (c : type.classHierarchyWithObject.reverseView) {
//						parentScope = Scopes::scopeFor(c.selectedFeatures(sel), parentScope)
//					}
//					return Scopes::scopeFor(features, parentScope)
//}
//
//				/*if(head instanceof AttributeReference) {
//					switch (head.ref) {
//							Attribute: {
//								val type = head.ref.type;
//								switch (type) {
//									//SimpleType: return Scopes::scopeFor(type.eContents)
//									ComplexType: {
//										val ref = type.ref
//										switch (ref) {
//											Party:	return Scopes::scopeFor(ref.attributes)
//											Asset: return Scopes::scopeFor(ref.attributes)
//											default: return IScope.NULLSCOPE
//										}
//									}
//									default: return IScope.NULLSCOPE
//								}
//							}
//							default: return IScope.NULLSCOPE
//						}
//				}*/
//				
//			}
//		}
//
//		if (reference == CmlPackage.Literals.ATOMIC_ACTION__ARGS) {
//			if (context instanceof AtomicAction) {
//				if (context.action !== null) {
//					val args = EcoreUtil2.getAllContentsOfType(context.action, Attribute)
//					return Scopes.scopeFor(args);
//				}
//			}
//		}
//		
//		if (reference == CmlPackage.Literals.ATOMIC_ACTION__PRE_CONDITION) {
//			if (context instanceof AtomicAction) {
//				if (context !== null && context.action !== null) {
//					val args = EcoreUtil2.getAllContentsOfType(context.action, Attribute)
//					return Scopes.scopeFor(args);
//				}
//			}
//		}
//		
//		if (reference == CmlPackage.Literals.ACTOR__PARTY) {
//			if (context instanceof Actor) {
//				val rootElement = EcoreUtil2.getRootContainer(context)
//				val attributes = EcoreUtil2.getAllContentsOfType(rootElement, Attribute)
//				val candidates = attributes.filter(a|a.type instanceof ComplexType)
//				val parties = candidates.filter(a|(a.type as ComplexType).ref instanceof Party)
//				return Scopes.scopeFor(parties)
//			}
//		}
//		
//		if (reference == CmlPackage.Literals.DOT_EXPRESSION_START__REF) {
//			
//			/*if (context instanceof AtomicAction) {
//				var result = IScope.NULLSCOPE
//				val rootElement = EcoreUtil2.getRootContainer(context)
//				val parties = EcoreUtil2.getAllContentsOfType(rootElement, Party)
//				result = Scopes.scopeFor(parties, result)
//				result = Scopes.scopeFor(context.args, result);
//				return result;
//			}*/
//			
//			if (context instanceof DotExpressionStart) {
//				/*var result = IScope.NULLSCOPE
//				val rootElement = EcoreUtil2.getRootContainer(context)
//				val parties = EcoreUtil2.getAllContentsOfType(rootElement, Party)
//				result = Scopes.scopeFor(parties.filter[context.action == type.actions], result)
//				result = Scopes.scopeFor(context.args, result);
//				
//				val attributes = EcoreUtil2.getAllContentsOfType(rootElement, Attribute)
//				return Scopes.scopeFor(attributes);*/
//				
//				//val args = EcoreUtil2.getAllContentsOfType(context.action, Attribute)
//				val aa = EcoreUtil2.getContainerOfType(context, AtomicAction)
//				if(aa !== null)
//					return Scopes.scopeFor(aa.args);
//			}
//		}
//		
//		
////		if (reference == CmlPackage.Literals.EXPRESSION__REF) {
////
////			/*if (context instanceof AtomicAction) {
////			 * 	var result = IScope.NULLSCOPE
////			 * 	val rootElement = EcoreUtil2.getRootContainer(context)
////			 * 	val parties = EcoreUtil2.getAllContentsOfType(rootElement, Party)
////			 * 	result = Scopes.scopeFor(parties, result)
////			 * 	result = Scopes.scopeFor(context.args, result);
////			 * 	return result;
////			 }*/
////			if (context instanceof AtomicAction) {
////				/*var result = IScope.NULLSCOPE
////				 * val rootElement = EcoreUtil2.getRootContainer(context)
////				 * val parties = EcoreUtil2.getAllContentsOfType(rootElement, Party)
////				 * result = Scopes.scopeFor(parties.filter[context.action == type.actions], result)
////				 * result = Scopes.scopeFor(context.args, result);
////				 * 
////				 * val attributes = EcoreUtil2.getAllContentsOfType(rootElement, Attribute)
////				 return Scopes.scopeFor(attributes);*/
////				val args = EcoreUtil2.getAllContentsOfType(context.action, Attribute)
////				return Scopes.scopeFor(args, [Attribute attr|return QualifiedName.create(attr.name)], IScope.NULLSCOPE);
////			}
////		}
//		
//		//if (reference == CmlPackage.Literals.ATOMIC_ACTION__PRE_CONDITION) {
//		if (reference == CmlPackage.Literals.ATOMIC_ACTION__PRE_CONDITION) {	
//			/*if (context instanceof AtomicAction) {
//				var result = IScope.NULLSCOPE
//				val rootElement = EcoreUtil2.getRootContainer(context)
//				val parties = EcoreUtil2.getAllContentsOfType(rootElement, Party)
//				result = Scopes.scopeFor(parties, result)
//				result = Scopes.scopeFor(context.args, result);
//				return result;
//			}*/
//			
////			if (context instanceof AtomicAction) {
////				/*var result = IScope.NULLSCOPE
////				val rootElement = EcoreUtil2.getRootContainer(context)
////				val parties = EcoreUtil2.getAllContentsOfType(rootElement, Party)
////				result = Scopes.scopeFor(parties.filter[context.action == type.actions], result)
////				result = Scopes.scopeFor(context.args, result);
////				
////				val attributes = EcoreUtil2.getAllContentsOfType(rootElement, Attribute)
////				return Scopes.scopeFor(attributes);*/
////				
////				//val args = EcoreUtil2.getAllContentsOfType(context.action, Attribute)
////				//	return Scopes.scopeFor(args, [Attribute attr | return QualifiedName.create("haha" + attr.name)], IScope.NULLSCOPE);
////					
////            if (context.args !== null) {
////					val result = newArrayList
////					for (i : context.args) {
////						result.add(EObjectDescription.create(QualifiedName.create(context.action.name, i.name), i))
////
////					}
////					println(result)
////					return new SimpleScope(IScope.NULLSCOPE, result)
////				}
////			}
//			
//			
//		}
//		/* 
//		if (reference == CmlPackage.Literals.DOT_EXPRESSION__TAIL) {
//			
//			if (context instanceof DotExpression) {
//				val head = context.head;
//				switch (head) {
//					DotExpressionStart:
//						switch (head.ref) {
//							Attribute: {
//								val type = (head.ref as Attribute).typeDef;
//								switch (type) {
//									//SimpleType: return Scopes::scopeFor(type.eContents)
//									ComplexTypeRef: {
//										val ref = type.ref
//										switch (ref) {
//											Party:	return Scopes::scopeFor(ref.attributes)
//											Entity: return Scopes::scopeFor(ref.attributes)
//											default: return IScope.NULLSCOPE
//										}
//									}
//									default: return IScope.NULLSCOPE
//								}}
//							}
//							Party: return Scopes::scopeFor((head.ref as Party).attributes)
//							default: return IScope.NULLSCOPE
//						}
//					DotExpression: {
//						val tail = head.tail
//						switch (tail) {
//							Attribute: {
//								val type = (head.tail as Attribute).typeDef
//								switch (type) {
//									SimpleType: {
//										//return Scopes::scopeFor(type.eContents)
//									}
//									ComplexTypeRef: {
//										val ref = type.ref
//										switch (ref) {
//											Party:	return Scopes::scopeFor(ref.attributes)
//											Entity: return Scopes::scopeFor(ref.attributes)
//											default: return IScope.NULLSCOPE
//										}
//									}
//									default: return IScope.NULLSCOPE
//								}
//							}
//							default: return IScope.NULLSCOPE
//						}
//					}
//					default: return IScope.NULLSCOPE
//				}
//			}
//		}*/
//
//		super.getScope(context, reference)
//	}
//	
//	/*def Iterable<Attribute> filterAttribute(ComplexType ct, EObject ctx) {
//		val rootElement = EcoreUtil2.getRootContainer(ctx)
//		val attributes = EcoreUtil2.getAllContentsOfType(rootElement, Attribute)
//		val candidates = attributes.filter(a|a.type instanceof ComplexType)
//		candidates.filter(a|(a.type as ComplexType).ref instanceof ct.class)
//	}*/
	
	@Inject extension CmlTypeProvider
	@Inject extension CmlLib

	override getScope(EObject context, EReference reference) {

		if (reference == CmlPackage.Literals.MEMBER_SELECTION__MEMBER) {
			if (context instanceof MemberSelection) {
				var parentScope = IScope::NULLSCOPE
				var type = context.receiver.typeFor
				println(context.receiver + ": " + type)
				if (type === null || type.isPrimitiveType)
					return parentScope
				if (type instanceof Class) {
					val features = (type as Class).selectedFeatures(context)
					println(features)
					for (c : type.classHierarchyWithObject.reverseView) {
					  	parentScope = Scopes::scopeFor(c.selectedFeatures(context), parentScope)
					}
					return Scopes::scopeFor(features, parentScope)
				}
			}
		}

		if (reference == CmlPackage.Literals.ENUMERATION_LITERAL__LITERAL) {
			if (context instanceof EnumerationLiteral) {
				var parentScope = IScope::NULLSCOPE
				if (context.enumeration instanceof Enumeration)
					return Scopes::scopeFor(context.enumeration.elements, parentScope)
				else
					return parentScope
			}
		}

		super.getScope(context, reference)
	}

	def selectedFeatures(Class type, MemberSelection sel) {
		if (sel.methodinvocation)
			type.operations
		else
			type.attributes
	}

}
