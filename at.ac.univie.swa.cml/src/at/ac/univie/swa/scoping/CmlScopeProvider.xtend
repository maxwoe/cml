/*
 * generated by Xtext 2.16.0
 */
package at.ac.univie.swa.scoping

import at.ac.univie.swa.CmlModelUtil
import at.ac.univie.swa.cml.Actor
import at.ac.univie.swa.cml.Block
import at.ac.univie.swa.cml.Class
import at.ac.univie.swa.cml.CmlPackage
import at.ac.univie.swa.cml.EnumerationLiteral
import at.ac.univie.swa.cml.ForLoop
import at.ac.univie.swa.cml.MemberFeatureCall
import at.ac.univie.swa.cml.Operation
import at.ac.univie.swa.cml.VariableDeclaration
import at.ac.univie.swa.typing.CmlTypeConformance
import at.ac.univie.swa.typing.CmlTypeProvider
import javax.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CmlScopeProvider extends AbstractCmlScopeProvider {

	@Inject extension CmlTypeProvider
	@Inject extension CmlModelUtil
	@Inject extension CmlTypeConformance

	override getScope(EObject context, EReference reference) {
		if (reference == CmlPackage.Literals.SYMBOL_REFERENCE__REF) {
			return scopeForSymbolRef(context)
		} else if (context instanceof MemberFeatureCall) {
			return scopeForMemberFeatureCall(context)
		} else if (reference == CmlPackage.Literals.ENUMERATION_LITERAL__LITERAL) {
			return scopeForEnumLiteral(context)
		} else if (reference == CmlPackage.Literals.ACTOR__PARTY) {
			if (context instanceof Actor) {
				var parentScope = IScope::NULLSCOPE
				for (c : context.containingClass.classHierarchyWithObject.toArray().reverseView) {
					parentScope = Scopes::scopeFor((c as Class).attributes/*.filter[!inferType.isPrimitive && (inferType.subclassOfParty || inferType.conformsToParty)]*/, parentScope)
				}
				return Scopes::scopeFor(context.containingClass.attributes/*.filter[!inferType.isPrimitive && (inferType.subclassOfParty || inferType.conformsToParty)]*/, parentScope)
			}
		}
		return super.getScope(context, reference)
	}

	def protected IScope scopeForSymbolRef(EObject context) {
		var container = context.eContainer
		
		return switch (container) {
			Operation:
				Scopes.scopeFor(container.params, scopeForSymbolRef(container))
			Block:
				Scopes.scopeFor(
					container.statements.takeWhile[it != context].filter(VariableDeclaration),
					scopeForSymbolRef(container))
			Class: {
				var parentScope = IScope::NULLSCOPE
				for (c : container.classHierarchyWithObject.toArray().reverseView) {
					parentScope = Scopes::scopeFor((c as Class).attributes, parentScope)
				}
				return Scopes::scopeFor(container.attributes, parentScope)
			}
			ForLoop:
				Scopes.scopeFor(#[container.declaration], scopeForSymbolRef(container) )
			default:
				scopeForSymbolRef(container)
		}
	}

	def protected IScope scopeForMemberFeatureCall(MemberFeatureCall mfc) {
		var type = mfc.receiver.typeFor

		if (type === null || type.isPrimitive)
			return IScope.NULLSCOPE

		if (type instanceof Class) {
			var parentScope = IScope::NULLSCOPE
			for (c : type.classHierarchyWithObject.toArray().reverseView) {
				parentScope = Scopes::scopeFor((c as Class).selectedFeatures(mfc), parentScope)
			}
			return Scopes::scopeFor(type.selectedFeatures(mfc), parentScope)
		}
	}

	def protected IScope scopeForEnumLiteral(EObject context) {
		if (context instanceof EnumerationLiteral) {
			var parentScope = IScope::NULLSCOPE
			
			if (context.enumeration === null || context.enumeration.isPrimitive)
				return parentScope
			
			if (context.enumeration.subclassOfEnum) {
				return Scopes::scopeFor(context.enumeration.enumElements, parentScope)
			} else
				return parentScope
		}
	}

	def selectedFeatures(Class type, MemberFeatureCall mfc) {
		if (mfc.operationCall)
			type.operations + type.attributes
		else
			type.attributes + type.operations
	}

}
