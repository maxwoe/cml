grammar at.ac.univie.swa.Cml with org.eclipse.xtext.common.Terminals

generate cml 'http://swa.univie.ac.at/Cml'

CmlProgram:
	('namespace' name=QualifiedName)?
	imports+=Import*
	declarations+=Declaration*;

Declaration:
	Class | Party | Asset | Event | Enumeration | Contract;

Class: 
	(abstract?='abstract')? kind='class' name=ID ('extends' superclass=[Class|QualifiedName])?
	(BEGIN
		features+=FeatureAttributeAndOperation*
	END)?;

Contract returns Class:
	(abstract?='abstract')? kind='contract' name=ID ('extends' superclass=[Class|QualifiedName])?
	BEGIN
		features+=FeatureAttributeAndOperation*
	END;
	
Party returns Class:
	(abstract?='abstract')? kind='party' name=ID ('identifier' id=[Attribute])? ('extends' superclass=[Class|QualifiedName])? 
	BEGIN
		 features+=FeatureAttribute+
	END;
	
Asset returns Class:
	(abstract?='abstract')? kind='asset' name=ID ('identifier' id=[Attribute])? ('extends' superclass=[Class|QualifiedName])? 
	BEGIN
		features+=FeatureAttribute+
	END;

Event returns Class:
	kind='event' name=ID
	(BEGIN
		features+=FeatureAttribute+
	END)?;

Enumeration returns Class:
	kind='enum' name=ID
	BEGIN
		features+=FeatureEnumeration+
	END;

EnumerationElement:
	name = ID;

Type: Class;
Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

Feature:
	Attribute | Operation /* | Clause*/ | EnumerationElement;
	
FeatureAttribute returns Feature:
	Attribute;
	
FeatureAttributeAndOperation returns Feature:
	Attribute | Operation;

//FeatureAttributeAndClause returns Feature:
//	AttributeWithInitExpr  | Clause;
	
FeatureEnumeration returns Feature:
	EnumerationElement;

Attribute:
	TypedDeclaration;

Operation:
	access=AccessLevel? TypedDeclaration
	'(' (params+=Attribute (',' params+=Attribute)*)? ')'
	(body=Block)?;

enum AccessLevel:
	PRIVATE='private' | PROTECTED='protected' | PUBLIC='public';

Block:
	{Block} BEGIN statements+=Statement* END;

Statement:
	VariableDeclaration |
	Return |
	Expression |
	IfStatement;

VariableDeclaration:
	'var' TypedDeclaration '=' expression=Expression;

Return:
	'return' expression=Expression;

IfStatement:
	'if' '(' expression=Expression ')' thenBlock=IfBlock
	(=>'else' elseBlock=IfBlock)?;

IfBlock returns Block:
	statements+=Statement
	| Block;

fragment TypedDeclaration *:
	type=[Class|QualifiedName] name=ID;

NamedElement:
	Class | Feature | VariableDeclaration;

Expression: AssignmentExpression;

AssignmentExpression returns Expression:
	ImpliesExpression ({AssignmentExpression.left=current} '=' right=Expression)?;
	
ImpliesExpression returns Expression:
	XorExpression (=>({ImpliesExpression.left=current} op='implies') right=XorExpression)*;

XorExpression returns Expression:
	OrExpression (=>({XorExpression.left=current} op='xor') right=OrExpression)*;

OrExpression returns Expression:
	AndExpression (=>({OrExpression.left=current} op='or') right=AndExpression)*;

AndExpression returns Expression:
	EqualityExpression (=>({AndExpression.left=current} op='and') right=EqualityExpression)*;

EqualityExpression returns Expression :
	RelationalExpression (=>({EqualityExpression.left=current} op=('=='|'!=')) right=RelationalExpression)*;

RelationalExpression returns Expression:
	OtherOperatorExpression
	(=>({InstanceOfExpression.expression=current} 'instanceof') type=[Class|QualifiedName] |
	 =>({RelationalExpression.left=current} op=('>' | '<' | '>=' | '<=')) right=OtherOperatorExpression)*;

OtherOperatorExpression returns Expression:
	AdditiveExpression (=>({OtherOperatorExpression.leftOperand=current} op='=>') right=AdditiveExpression)*;
	
AdditiveExpression returns Expression: 
	MultiplicativeExpression (=>({AdditiveExpression.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression: 
	UnaryExpression (=>({MultiplicativeExpression.left=current} op=('*' | '/')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('not' | '!' | '-' | '+') operand=UnaryExpression | CastedExpression;
	
CastedExpression returns Expression:
	PostfixExpression (=>({CastedExpression.target=current} 'as') type=[Class|QualifiedName])*;

PostfixExpression returns Expression:
	SelectionExpression =>({PostfixExpression.operand=current} op=("++" | "--" | "@pre"))?;

SelectionExpression returns Expression:
	PrimaryExpression
	(=>({MemberSelection.receiver=current} '.') member=[Feature]
	(=>methodinvocation ?= '(' (args += Expression (',' args += Expression)* )?  ')' )?
	memberCallArguments+=Closure?	
	)*;

Closure returns Expression:
	=>({Closure}
	'[')
		(expressions+=ExpressionOrVarDeclaration)*
	']';

ExpressionOrVarDeclaration returns Expression:
	VariableDeclaration | Expression;
	
PrimaryExpression returns Expression:	
	LiteralExpression |
	{ThisExpression} 'this' |
	{SuperExpression} 'super' |
	{CallerExpression} 'caller' |
	{SymbolReference} symbol=[NamedElement] |
	{Enumeration} enumeration=[NamedElement] '::' literal=[EnumerationElement] |
	{New} 'new' type=[Class|QualifiedName] '--' |
	'(' Expression ')';

LiteralExpression returns Expression:
	{IntegerLiteral} value=INT |
	{BooleanLiteral} value=('false' | 'true') |
	{StringLiteral} value=STRING |
	{RealLiteral} value=REAL |
	{DurationLiteral} value=INT unit=TimeUnit |
	{DateTimeLiteral} value=DATE |
	{NullLiteral} 'null' |
	{SetLiteral} '{' (elements+=Expression (',' elements+=Expression )*)? '}' |
	{ArrayLiteral} '[' (elements+=Expression (',' elements+=Expression)*)? ']';

enum TimeUnit: 
	MINUTE='minutes'|
	HOUR='hours'|
	DAY='days'|
	WEEK='weeks'|
	SECOND='seconds';
	
QualifiedName:
    ID ('.' ID)*;

QualifiedNameWithWildcard:
    QualifiedName '.*'?;

terminal DATE: '0'..'9''0'..'9''0'..'9''0'..'9' '-' '0'..'9''0'..'9' '-' '0'..'9''0'..'9';
terminal REAL: ('0'..'9')+'.'('0'..'9'+); 	
terminal BEGIN: 'synthetic:BEGIN';  // increase indentation
terminal END: 'synthetic:END';      // decrease indentation