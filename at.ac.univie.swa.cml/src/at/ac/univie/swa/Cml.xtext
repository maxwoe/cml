grammar at.ac.univie.swa.Cml with org.eclipse.xtext.common.Terminals

generate cml 'http://swa.univie.ac.at/Cml'

CmlProgram:
	('namespace' name=QualifiedName)?
	imports+=Import*
	declarations+=Declaration*;

Declaration:
	Class | Party | Asset | Event | Enumeration | Contract;

Class:
	(abstract?='abstract')? kind='class' name=ID ('extends' superclass=[Class|QualifiedName])?
	(BEGIN
	features+=FeatureAttributeAndOperation*
	END)?;

Contract returns Class:
	(abstract?='abstract')? kind='contract' name=ID ('extends' superclass=[Class|QualifiedName])?
	BEGIN
	features+=FeatureAttributeAndOperationAndClause*
	END;

Party returns Class:
	(abstract?='abstract')? kind='party' name=ID ('identifier' id=[Attribute])? ('extends' superclass=[Class|QualifiedName])?
	BEGIN
	features+=FeatureAttribute+
	END;

Asset returns Class:
	(abstract?='abstract')? kind='asset' name=ID ('identifier' id=[Attribute])? ('extends' superclass=[Class|QualifiedName])?
	BEGIN
	features+=FeatureAttribute+
	END;

Event returns Class:
	kind='event' name=ID
	(BEGIN
	features+=FeatureAttribute+
	END)?;

Enumeration returns Class:
	kind='enum' name=ID
	BEGIN
	features+=FeatureEnumeration+
	END;

EnumerationElement:
	name=ID;

Clause:
	'clause' name=ID
	BEGIN
	antecedent=Antecedent
	actor=Actor
	action=DeonticAction
	END;

Antecedent:
	{Antecedent} temporal=TimeConstraint? general=Constraint?;

TimeConstraint:
	'due' closed?='within'? timeframe=Expression? period=PeriodicTime? precedence=TemporalPrecedence reference=(TimeQuery
	| Expression);

Constraint:
	'given' expression=Expression;

Actor:
	'party' party=[Attribute];

enum Deontic:
	MUST='must' | MAY='may' | MUST_NOT='must_not';

DeonticAction:
	deontic=Deontic compoundAction=CompoundAction;

CompoundAction:
	OrCompoundAction;

OrCompoundAction returns CompoundAction:
	SeqCompoundAction ({OrCompoundAction.left=current} op=('or') right=SeqCompoundAction)*;

SeqCompoundAction returns CompoundAction:
	AndCompoundAction ({SeqCompoundAction.left=current} op=('then') right=AndCompoundAction)*;

AndCompoundAction returns CompoundAction:
	AtomicCompoundAction ({AndCompoundAction.left=current} op=('and') right=AtomicCompoundAction)*;

AtomicCompoundAction returns CompoundAction:
	'(' CompoundAction ')' | reference=[Operation];

PeriodicTime:
	'every' period=Expression 'from' start=(TimeQuery | Expression) ('until' end=(TimeQuery | Expression))?;

enum TemporalPrecedence:
	BEFORE='before' |
	BEFORE_OR_EQUALS='beforeOrEquals' |
	EQUALS='equals' |
	AFTER_OR_EQUALS='afterOrEquals' |
	AFTER='after';

ClauseQuery:
	'clause' ref=[Clause];

EventQuery:
	'event' ref=[Attribute];

ActionQuery:
	multiplicity=('all' | 'any' | 'this')? partyRef=[Attribute] query='did' actionRef=[Operation];

TimeQuery:
	ClauseQuery | EventQuery | ActionQuery;

Type:
	Class;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

Feature:
	Attribute | Operation | Clause | EnumerationElement;

FeatureAttribute returns Feature:
	Attribute;

FeatureAttributeAndOperation returns Feature:
	Attribute | Operation;

FeatureAttributeAndOperationAndClause returns Feature:
	FeatureAttributeAndOperation | Clause;

FeatureEnumeration returns Feature:
	EnumerationElement;

Attribute:
	TypedDeclaration;

Operation:
	access=AccessLevel? TypedDeclaration
	'(' (params+=Attribute (',' params+=Attribute)*)? ')'
	(body=Block)?;

enum AccessLevel:
	PRIVATE='private' | PROTECTED='protected' | PUBLIC='public';

Block:
	{Block} BEGIN statements+=Statement* END;

Statement:
	VariableDeclaration |
	IfStatement |
	EnsureStatement |
	ThrowStatement |
	ReturnStatement |
	Expression;

VariableDeclaration:
	'var' TypedDeclaration '=' expression=Expression;

ReturnStatement:
	'return' expression=Expression;

IfStatement:
	'if' (('(' condition=Expression ')') | (-> condition=Expression)) thenBlock=ConditionalBlock
	(=> 'else' elseBlock=ConditionalBlock)?;
	
ConditionalBlock returns Block:
	statements+=Statement | 
	Block;
	
ThrowStatement:
	'throw' expression=Expression;

EnsureStatement:
	'ensure' expression=Expression (=>'else' throwExpression=Expression)?;

fragment TypedDeclaration *:
	type=[Class|QualifiedName] name=ID;

NamedElement:
	Class | Feature | VariableDeclaration;

Expression:
	AssignmentExpression;

AssignmentExpression returns Expression:
	ImpliesExpression ({AssignmentExpression.left=current} '=' right=Expression)?;

ImpliesExpression returns Expression:
	XorExpression (=> ({ImpliesExpression.left=current} op='implies') right=XorExpression)*;

XorExpression returns Expression:
	OrExpression (=> ({XorExpression.left=current} op='xor') right=OrExpression)*;

OrExpression returns Expression:
	AndExpression (=> ({OrExpression.left=current} op='or') right=AndExpression)*;

AndExpression returns Expression:
	EqualityExpression (=> ({AndExpression.left=current} op='and') right=EqualityExpression)*;

EqualityExpression returns Expression:
	RelationalExpression (=> ({EqualityExpression.left=current} op=('==' | '!=')) right=RelationalExpression)*;

RelationalExpression returns Expression:
	OtherOperatorExpression
	(=> ({InstanceOfExpression.expression=current} 'instanceof') type=[Class|QualifiedName] |
	=> ({RelationalExpression.left=current} op=('>' | '<' | '>=' | '<=')) right=OtherOperatorExpression)*;

OtherOperatorExpression returns Expression:
	AdditiveExpression (=> ({OtherOperatorExpression.leftOperand=current} op='=>') right=AdditiveExpression)*;

AdditiveExpression returns Expression:
	MultiplicativeExpression (=> ({AdditiveExpression.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression:
	UnaryExpression (=> ({MultiplicativeExpression.left=current} op=('*' | '/')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('not' | '!' | '-' | '+') operand=UnaryExpression | CastedExpression;

CastedExpression returns Expression:
	PostfixExpression (=> ({CastedExpression.target=current} 'as') type=[Class|QualifiedName])*;

//PostfixExpression returns Expression:
//	SelectionExpression => ({PostfixExpression.operand=current} op=("++" | "--" | "@pre"))?;

PostfixExpression returns Expression:
	SelectionExpression
	(=> ({PostfixExpression.operand=current}
	op=("++" | "--" | "@pre"))
	|
	=> ({ArrayAccessExpression.array=current}
	'[' indexes+=Expression ']' (=> '[' indexes+=Expression ']')*))?;
 
SelectionExpression returns Expression:
	PrimaryExpression
	(=> ({MemberSelection.receiver=current} '.') member=[Feature]
	(=> methodinvocation?='(' (args+=Expression (',' args+=Expression)*)? ')')?
	memberCallArguments+=Closure?)*;

Closure returns Expression:
	=> ({Closure}
	'[')
	(expressions+=ExpressionOrVarDeclaration)*
	']';

ExpressionOrVarDeclaration returns Expression:
	VariableDeclaration | Expression;

PrimaryExpression returns Expression:
	LiteralExpression |
	{ThisExpression} 'this' |
	{SuperExpression} 'super' |
	{CallerExpression} 'caller' |
	{SymbolReference} symbol=[NamedElement] |
	{Enumeration} enumeration=[NamedElement] '::' literal=[EnumerationElement] |
	{New} 'new' type=[Class|QualifiedName] '(' ')' |
	'(' Expression ')';

LiteralExpression returns Expression:
	{IntegerLiteral} value=INT |
	{BooleanLiteral} value=('false' | 'true') |
	{StringLiteral} value=STRING |
	{RealLiteral} value=REAL |
	{DurationLiteral} value=INT unit=TimeUnit |
	{DateTimeLiteral} value=DATE |
	{NullLiteral} 'null' |
	{SetLiteral} '{' (elements+=Expression (',' elements+=Expression)*)? '}' |
	{ArrayLiteral} '[' (elements+=Expression (',' elements+=Expression)*)? ']';

enum TimeUnit:
	MINUTE='minutes' |
	HOUR='hours' |
	DAY='days' |
	WEEK='weeks' |
	SECOND='seconds';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

terminal DATE:
	'0'..'9' '0'..'9' '0'..'9' '0'..'9' '-' '0'..'9' '0'..'9' '-' '0'..'9' '0'..'9';

terminal REAL:
	('0'..'9')+ '.' ('0'..'9'+);

terminal BEGIN:
	'synthetic:BEGIN'; // increase indentation
terminal END:
	'synthetic:END'; // decrease indentation