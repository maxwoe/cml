grammar at.ac.univie.swa.Cml with org.eclipse.xtext.common.Terminals

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

generate cml 'http://swa.univie.ac.at/Cml'

Contract:
	'contract' name=ID
	BEGIN
		(parties+=Party |
		 events+=Event |
		 attributes+=Attribute |
		 types+=ComplexType |
		 clauses+=Clause)*
	END;

Classifier:
	Feature | Record | Entity | Party | Event | Clause;
	
Feature:
    Attribute | Action;
	
Party:
	'party' name=ID ':' many?='many'?  type=[Entity|ID];

Action:
	visibility=Visibility? name=ID '(' (args+=Attribute (',' args+=Attribute)*)? ')' (':' returnType=AttributeType)?;

enum Visibility:
	PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';
		
AttributeType:
	/*(collection = Collection)?*/ many?='many'? type=Type (array ?='[' (length=INT)? ']')?;

Collection:
	{Set} 'set' | {Bag} 'bag';
	
Type:
	SimpleType | ComplexTypeRef;
	
SimpleType:
	{IntegerType} 'integer' | {BooleanType} 'boolean' | {StringType} 'string' | {DateType} 'date';

ComplexType:
	Record | Entity;
	
ComplexTypeRef:
	ref=[ComplexType|ID];

Entity:
	'entity' name=ID ('extends' superType=[Entity|ID])?
	BEGIN
		//features+=Feature* 
		(attributes+=Attribute |
		 types+=ComplexType |
		 actions+=Action)*
	END;
	
Record:
	'record' name=ID
	BEGIN
		attributes+=Attribute+
	END;
	  
Attribute:
	name=ID ':' type=AttributeType ('=' expr=Expression)?;

Event:
	'event' name=ID '(' (args+=Attribute (',' args+=Attribute)*)? ')';

Clause:
	'clause' name=ID
	BEGIN
		antecedent=Antecedent
		actor=Actor
		action=DeonticAction
		reparation=Reparation?
	END;

Antecedent:
	{Antecedent} temporal=TemporalConstraint? general=Constraint?;

TemporalConstraint:
	'due' constraint=TimeConstraint;
	
Constraint:
	'given' expression=Expression;

Actor:
	'party' party=[Party|ID];

enum Deontic:
	MUST='must' | MAY='may' | MUST_NOT= 'must_not';

DeonticAction:
	deontic=Deontic compoundAction=CompoundAction;

CompoundAction:
	OrAction;

OrAction returns CompoundAction:
	SeqAction ({OrAction.left=current} op=('or') right=SeqAction)*;

SeqAction returns CompoundAction:
	AndAction ({SeqAction.left=current} op=('then') right=AndAction)*;
	
AndAction returns CompoundAction:
	AtomicAction ({AndAction.left=current} op=('and') right=AtomicAction)*;

AtomicAction returns CompoundAction:
	'(' CompoundAction ')' | ClauseAction;

ClauseAction:
	actionRef=[Action|ID] '(' (argsRef+=[Attribute] (',' argsRef+=[Attribute])*)? ')'
	(BEGIN
		'when' preCondition=Expression?
		'then' postCondition=Expression?
	END)?;
	
Reparation:
	'otherwise' referTo=[Clause|ID];

TimeConstraint:
	closed?='within'? timeframe=(RelativeTime | DotExpression)? period=PeriodicTime? precedence=TemporalPrecedence reference=(AbsoluteTime | DotExpression);

PeriodicTime:
	'every' period=(RelativeTime | DotExpression) 'from' start=(AbsoluteTime | DotExpression) ('until' end=(AbsoluteTime | DotExpression))?;
	
enum TemporalPrecedence:
	BEFORE='before' |
	//BEFORE_OR_EQUALS='before or at the same time as' |
	//EQUALS ='at the same time as' |
	//AFTER_OR_EQUALS='after or at the same time as' |
	AFTER='after';

ClauseQuery:
	'clause' ref=[Clause] 'fulfilled';

EventQuery:
	'event' ref=[Event] 'occurred';
	
ActionQuery:
	partyRef=[Party] multiplicity=('all'|'any'|'current')? query=('finished') actionRef=[Action];
	
TimeQuery:
	ClauseQuery | EventQuery | ActionQuery;
	
Time:
	AbsoluteTime | RelativeTime;

AbsoluteTime:
	TimeQuery | globalTimeRef=GlobalTimeReference;
	
RelativeTime:
	TimeFrame;

enum GlobalTimeReference:
	NOW='$now' | CONTRACT_START='$contractStart' | CONTRACT_END='$contractEnd';
	
TimeFrame:
	{TimeFrame} (weeks=INT 'weeks') | {TimeFrame} (days=INT 'days') | {TimeFrame} (hours=INT 'hours') | {TimeFrame} (minutes=INT 'minutes') | {TimeFrame} (seconds=INT 'seconds');
	
Expression:
	Assignment;

Assignment returns Expression:
	Implies ({Assignment.left=current} '=' right=Implies)*;

Implies returns Expression:
	Conditional ({Implies.left=current} op=('=>' | 'implies') right=Conditional)*; 

Conditional returns Expression:
	Or ({Conditional.left=current} '?' trueCase=Or ':' falseCase=Or)?;// |
	//'if' Or ({Conditional.left=current} 'then' trueCase=Or 'else' falseCase=Or)? ;
  
Or returns Expression:
	And ({Or.left=current} op=('||' | 'or') right=And)*;

And returns Expression:
	Equality ({And.left=current} op=('&&' | 'and') right=Equality)*;

Equality returns Expression:
	Relation ({Equality.left=current} op=('==' | '!=') right=Relation)*;

Relation returns Expression:
	PlusOrMinus ({Relation.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*;

PlusOrMinus returns Expression:
	MulOrDiv ({PlusOrMinus.left=current} op=('+' | '-') right=MulOrDiv)*;

MulOrDiv returns Expression:
	Unary ({MulOrDiv.left=current} op=('*' | '/') right=Unary)*;

Unary returns Expression:
	Postfix | {Unary} op=('+' | '-') right=Postfix;

Postfix returns Expression:
	Primary ({Postfix.left=current} op=('++'|'--'))*;

Primary returns Expression:
	'(' Expression ')' | {Not} op=('!' | 'not') expression=Primary | Atomic;

Atomic returns Expression:
	{IntegerConstant} value=INT | 
	{StringConstant} value=STRING | 
	{BooleanConstant} value=('true' | 'false') |
	DotExpression;

/*FeatureCall:
  OperationCall |
  (type=Type) |
  CollectionExpression |
TypeSelectExpression;

OperationCall:
	actionRef=[Action|ID] '(' (argsRef+=[Attribute] (',' argsRef+=[Attribute])*)? ')';

CollectionExpression:
  name=('collect'|'select'|'selectFirst'|'reject'|'exists'|'notExists'|'sortBy'|'forAll')
'(' (var=Identifier '|')? exp=Expression ')';*/

DotExpression returns Attribute:
    DotExpressionStart ({DotExpression.head=current} '.' tail=[Attribute])*;
 
DotExpressionStart returns Attribute:
    {DotExpressionStart} ref=[DotReference];

DotReference:
	Party | Attribute;
	 
//terminal BOOL returns ecore::EBoolean:
//	'true' | 'false';

//terminal NUMBER returns ecore::EBigDecimal:
//	/*('-')?*/ ('0'..'9')* ('.' ('0'..'9')+)?;

@Override 
terminal SL_COMMENT:
	'#' !('\n' | '\r')* ('\r'? '\n')?;
	
// The following synthetic tokens are used for the indentation-aware blocks
terminal BEGIN: 'synthetic:BEGIN';  // increase indentation
terminal END: 'synthetic:END';      // decrease indentation
