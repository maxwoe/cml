grammar at.ac.univie.swa.Cml with org.eclipse.xtext.common.Terminals

generate cml "http://www.ac.at/univie/swa/Cml" //"http://www.ac.at/univie/swa/Cml"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Contract:
	'contract' name=ID '{'
		(parties+=Party |
		features+=Feature |
		events+=Event |
		clauses+=Clause)* '}';

Party:
	'party' name=ID '{'
		(features+=Attribute |
		actions+=Action)* '}';

Action:
	name=ID '(' (args+=Attribute (',' args+=Attribute)*)? ')';

Feature:
	Attribute | Entity;
	
AbstractType:
	PrimitiveType | EntityType;
	
PrimitiveType:
	{IntegerType} "integer" | {BooleanType} "boolean" | {StringType} "string" | {DateType} "date";

EntityType:
	reference=[Entity|ID];

Entity:
	'entity' name=ID ('extends' superType=[Entity|ID])? '{'
		(features+=Attribute)* '}';

Attribute:
	(many?='many')? name=ID (((":" type=AbstractType)? "=" expr=Expression) | (":" type=AbstractType));

Event:
	'event' name=ID;

Clause:
	'clause' name=ID ('[' description=STRING ']')?
	antecedent=Antecedent
	actor=Actor
	action=DeonticAction
	consequent=Consequent?
	reparation=Reparation?;

Antecedent:
	{Antecedent} temporal=TemporalConstraint? general=Constraint?;

Consequent:
	'hence' expression=Expression;

Constraint:
	'given' expression=Expression;

Actor:
	'party' party=[Party|ID];

enum Deontic:
	MUST='must' | MAY='may' | MUST_NOT= 'must_not';

DeonticAction:
	deontic=Deontic action=[Action|ID];

Reparation:
	'otherwise' referTo=[Clause|ID];

TemporalConstraint:
	'due' constraint=TimeConstraint;

TimeConstraint:
	SimpleTimeConstraint | => BoundedTimeConstraint;

SimpleTimeConstraint:
	precedence=TemporalPrecedence? reference=TimeQuery;

BoundedTimeConstraint:
	closed?='within'? timeframe=TimeFrame precedence=TemporalPrecedence reference=TimeQuery;

enum TemporalPrecedence:
	BEFORE='before' | AFTER='after';

TimeExpression:
	TimeFrame | TimeQuery;

TimeFrame:
	{TimeFrame} (year=INT 'year')? (month=INT 'month')? (week=INT 'week')? (day=INT 'day')? (hour=INT 'hour')? (minute=INT 'min')? (second=INT 'sec')?;
	
TimeQuery:
	AbstractTimeQuery | GlobalTimeQuery ;

AbstractTimeQuery:
	reference=[TimeQuerySource|FQN];
	
TimeQuerySource:
	Action | Feature | Clause | Event;

GlobalTimeQuery:
	reference=TimeQueryReference;

enum TimeQueryReference:
	NOW='now' | START='start' | END='end';
	
Expression:
	Assignment;

Assignment returns Expression:
	Conditional ({Assignment.left=current} '=' right=Conditional)*;

Conditional returns Expression:
	Or ({Conditional.left=current} '?' trueCase=Or ':' falseCase=Or)? |
	'if' Or ({Conditional.left=current} 'then' trueCase=Or 'else' falseCase=Or)? ;
	
Or returns Expression:
	And ({Or.left=current} op=('||' | 'or') right=And)*;

And returns Expression:
	Equality ({And.left=current} op=('&&' | 'and') right=Equality)*;

Equality returns Expression:
	Relation ({Equality.left=current} op=('==' | '!=') right=Relation)*;

Relation returns Expression:
	PlusOrMinus ({Relation.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*;

PlusOrMinus returns Expression:
	MulOrDiv ({PlusOrMinus.left=current} op=('+' | '-') right=MulOrDiv)*;

MulOrDiv returns Expression:
	Unary ({MulOrDiv.left=current} op=('*' | '/') right=Unary)*;

Unary returns Expression:
	Postfix | {Unary} op=('+' | '-') right=Postfix;

Postfix returns Expression:
	Primary ({Postfix.left=current} op=('++'|'--'))*;
	
Primary returns Expression:
	'(' Expression ')' | {Not} op=('!' | 'not') expression=Primary | Atomic;

Atomic returns Expression:
	{IntegerConstant} value=INT | {StringConstant} value=STRING | {BooleanConstant} value=BOOL | {Reference} value=[ReferenceSource|FQN];

ReferenceSource:
	Feature | Clause;

//Number returns ecore::EBigDecimal:	
//	INT ('.' INT)?;

//terminal DECIMAL_NUMBER returns ecore::EBigDecimal:
// ("-")? ('0'..'9')* ('.' ('0'..'9')+)?;

terminal BOOL returns ecore::EBoolean:
	'true' | 'false';
	
FQN:
	ID ('.' ID)*;
