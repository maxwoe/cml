grammar at.ac.univie.swa.Cml with org.eclipse.xtext.common.Terminals

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

generate cml 'http://swa.univie.ac.at/Cml'

Contract:
	'contract' name=ID
	BEGIN
		(attributes+=Attribute |
		 types+=ComplexType |
		 events+=Event |
		 clauses+=Clause)*
	END;

Classifier:
	Attribute | Action | Entity | Enumeration | Party | Event | Clause;
	
Feature:
    Attribute | Action;
	
Action:
	visibility=Visibility? name=ID '(' (args+=Attribute (',' args+=Attribute)*)? ')' (':' returnType=Type)?;

enum Visibility:
	PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';
		
//AttributeType:
//	/*(collection = Collection)?*/ many?='many'? type=Type (array ?='[' (length=INT)? ']')?;
	
Type:
	IndividualType | CollectionType | ArrayType;

IndividualType:
	SimpleType | ComplexTypeRef;

Collection:
	{Set} 'set' | {Bag} 'bag';

ArrayType:
	ref=IndividualType '[' (length=INT)? ']';

CollectionType:
	collection=Collection ref=IndividualType;
	
SimpleType:
	{IntegerType} 'Integer' | {BooleanType} 'Boolean' | {StringType} 'String' | {DateType} 'DateTime';

ComplexType:
	Entity | Enumeration | Party;
	
ComplexTypeRef:
	ref=[ComplexType|FQN];

Enumeration:
	'enum' name=ID
	BEGIN
		elements+=EnumerationElement*
	END;

EnumerationElement:
	name = ID;

Party:
	'party' name=ID ('identified' 'by' id=[Attribute])? ('extends' superType=[Party|FQN])? 
	BEGIN
		(attributes+=Attribute |
		 actions+=Action)*
	END;
	
Entity:
	'object' name=ID ('identified' 'by' id=[Attribute])? ('extends' superType=[Entity|FQN])? 
	BEGIN
		attributes+=Attribute+
	END;
	  
Attribute:
	name=ID ':' typeDef=Type ('=' expr=Expression)?;

Event:
	'event' name=ID 
	(BEGIN
		args+=Attribute
	END)?;
	
Clause:
	'clause' name=ID
	BEGIN
		antecedent=Antecedent
		actor=Actor
		action=DeonticAction
		reparation=Reparation?
	END;

Antecedent:
	{Antecedent} temporal=TemporalConstraint? general=Constraint?;

TemporalConstraint:
	'due' constraint=TimeConstraint;
	
Constraint:
	'given' expression=Expression;

Actor:
	'party' party=[Party|FQN];

enum Deontic:
	MUST='must' | MAY='may' | MUST_NOT= 'must_not';

DeonticAction:
	deontic=Deontic compoundAction=CompoundAction;

CompoundAction:
	OrCompoundAction;

OrCompoundAction returns CompoundAction:
	SeqCompoundAction ({OrCompoundAction.left=current} op=('or') right=SeqCompoundAction)*;

SeqCompoundAction returns CompoundAction:
	AndCompoundAction ({SeqCompoundAction.left=current} op=('then') right=AndCompoundAction)*;
	
AndCompoundAction returns CompoundAction:
	AtomicCompoundAction ({AndCompoundAction.left=current} op=('and') right=AtomicCompoundAction)*;

AtomicCompoundAction returns CompoundAction:
	'(' CompoundAction ')' | AtomicAction;

AtomicAction:
	action=[Action|FQN] '(' (args+=[Attribute|FQN] (',' args+=[Attribute|FQN])*)? ')'
	(BEGIN
		'when' preCondition=Expression
		('then' postCondition=Expression)?
	END)?
	;
	
Reparation:
	'otherwise' referTo=[Clause|FQN];

TimeConstraint:
	closed?='within'? timeframe=(RelativeTime | DotExpression)? period=PeriodicTime? precedence=TemporalPrecedence reference=(AbsoluteTime | DotExpression);

PeriodicTime:
	'every' period=(RelativeTime | DotExpression) 'from' start=(AbsoluteTime | DotExpression) ('until' end=(AbsoluteTime | DotExpression))?;
	
enum TemporalPrecedence:
	BEFORE='before' |
	//BEFORE_OR_EQUALS='before or at the same time as' |
	//EQUALS ='at the same time as' |
	//AFTER_OR_EQUALS='after or at the same time as' |
	AFTER='after';

ClauseQuery:
	'clause' ref=[Clause|FQN] 'fulfilled';

EventQuery:
	'event' ref=[Event|FQN] 'occurred';
	
ActionQuery:
	multiplicity=('all'|'any'|'current')?  partyRef=[Party|FQN] query='executed' actionRef=[Action|FQN];
	
TimeQuery:
	ClauseQuery | EventQuery | ActionQuery;
	
Time:
	AbsoluteTime | RelativeTime;

AbsoluteTime:
	TimeQuery | globalTimeRef=GlobalTimeReference;
	
RelativeTime:
	TimeFrame;

enum GlobalTimeReference:
	NOW='$now' | CONTRACT_START='$contractStart' | CONTRACT_END='$contractEnd';
	
TimeFrame:
	{TimeFrame} (weeks=INT 'weeks') | {TimeFrame} (days=INT 'days') | {TimeFrame} (hours=INT 'hours') | {TimeFrame} (minutes=INT 'minutes') | {TimeFrame} (seconds=INT 'seconds');
	
Expression:
	ImpliesOpExp;
	
ImpliesOpExp returns Expression:
	XorOpExp ({ImpliesOpExp.source=current} op='implies' target=XorOpExp)*;

XorOpExp returns Expression:
	OrOpExp ({XorOpExp.source=current} op='xor' target=OrOpExp)*;

OrOpExp returns Expression:
	AndOpExp ({OrOpExp.source=current} op='or' target=AndOpExp)*;

AndOpExp returns Expression:
	EqOpExp ({AndOpExp.source=current} op='and' target=EqOpExp)*;

EqOpExp returns Expression :
	ComparisonOpExp ({EqOpExp.source=current} op=('<>'|'=') target=ComparisonOpExp)*;

ComparisonOpExp returns Expression:
	ConditionalOpExp ({ComparisonOpExp.source=current} op=('>' | '<' | '>=' | '<=') target=ConditionalOpExp)*;

ConditionalOpExp returns Expression:
	AdditionOpExp ('if' {ConditionalOpExp.source=current} 'then' trueCase=AdditionOpExp 'else' falseCase=AdditionOpExp)? ;
	
AdditionOpExp returns Expression : 
	MultiOpExp ({AdditionOpExp.source=current} op=('+' | '-') target=MultiOpExp)*;

MultiOpExp returns Expression : 
	UnaryOpExp ({MultiOpExp.source=current} op=('*' | '/') target=UnaryOpExp)*;

UnaryOpExp returns Expression:
	NavOpExp | {UnaryOpExp} op=('not' | '-' ) right=NavOpExp;
	
NavOpExp returns Expression:
	NavigationOpCallExp (({NavOpExp.source=current} op=(/*'.' |*/ '->') target=NavigationOpCallExp)*)?;

NavigationOpCallExp returns Expression :
	OperationCall
	//| NavigationOrAttributeCall
	| IterateExp
	| IteratorExp
	| CollectionOpCall
	| PrimaryExp;

OperationCall returns Expression:
	{OperationCall} name=ID '(' (arguments+=Expression ("," arguments+=Expression)*)? ')';
	
NavigationOrAttributeCall returns Expression:
	{NavigationOrAttributeCall} feature=ID;

IteratorExp returns Expression:
	{IteratorExp} name=IterativeOperationID '(' iterators+=Iterator  (','iterators+=Iterator)*  '|' body=Expression')';

Iterator:
	name=ID (':' type=CollectionType)?; 

IterateExp returns Expression:
	{IterateExp} op='iterate' '(' iterators+=Iterator  (','iterators+=Iterator)* ';'result=LocalVariable '|' body=Expression')';

LocalVariable returns LocalVariable :
	name=ID ':' type=CollectionType '=' initExp=Expression;

CollectionOpCall returns Expression:
	{CollectionOpCallExp} name=CollectionOperationID '(' (arguments+=Expression ("," arguments+=Expression)*)? ')';
	
IterativeOperationID returns ecore::EString :
	'exists' | 'forAll'	| 'isUnique' | 'any' | 'one' | 'collect' | 'select'	| 'reject';

CollectionOperationID returns ecore::EString :
	'size'	| 'includes' | 'excludes' | 'count' | 'includesAll' | 'excludesAll' | 'isEmpty' | 'notEmpty' | 'sum';
	
PrimaryExp returns Expression:
	'(' Expression ')' | Atomic;

Atomic returns Expression:
	{IntegerConstant} value=INT | 
	{StringConstant} value=STRING | 
	{BooleanConstant} value=('true' | 'false') |
	DotExpression;
	
DotExpression returns Ref:
    DotExpressionStart ({DotExpression.head=current} '.' tail=[Attribute])*;
 
DotExpressionStart returns Ref:
    {DotExpressionStart} ref=[Attribute];

FQN:
	ID ('.' ID)*;
	
//terminal BOOL returns ecore::EBoolean:
//	'true' | 'false';
//terminal NUMBER returns ecore::EBigDecimal:
//	/*('-')?*/ ('0'..'9')* ('.' ('0'..'9')+)?;
terminal BEGIN: 'synthetic:BEGIN';  // increase indentation
terminal END: 'synthetic:END';      // decrease indentation
