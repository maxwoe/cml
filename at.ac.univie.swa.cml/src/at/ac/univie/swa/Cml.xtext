grammar at.ac.univie.swa.Cml with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cml "http://swa.univie.ac.at/Cml"

Contract:
	'contract' name=ID
	BEGIN
		(parties+=Party |
		 attributes+=Attribute |
		 entities+=Entity |
		 events+=Event |
		 clauses+=Clause|
		 usages+=Usage)*
	END;

/*
Party:
	'party' name=ID
	BEGIN
		(features+=Attribute | 
		 actions+=Action)*
	END;
*/

Usage:
    "use" DotExpression;

Party:
	'party' name=ID
	BEGIN
		features+=Feature*
	END;

Feature:
    Attribute | Action;

Action:
	/*visibility=Visibility?*/ name=ID '(' (args+=Attribute (',' args+=Attribute)*)? ')';
	
AbstractType:
	PrimitiveType | EntityType;
	
PrimitiveType:
	{IntegerType} "integer" | {BooleanType} "boolean" | {StringType} "string" | {DateType} "date";

EntityType:
	reference=[Entity|ID];

Entity:
	'entity' name=ID /*('extends' superType=[Entity|ID])?*/
	BEGIN
		(attributes+=Attribute)* 
	END;

Attribute:
	name=ID (((":" (many?='many')? type=AbstractType)? "=" expr=Expression) | (":" type=AbstractType));

Event:
	'event' name=ID;

Clause:
	'clause' name=ID
	BEGIN
		antecedent=Antecedent
		actor=Actor
		action=DeonticAction
		reparation=Reparation?
	END;

Antecedent:
	{Antecedent} temporal=TemporalConstraint? general=Constraint?;

Constraint:
	'given' expression=Expression;

Actor:
	'party' party=[Party|ID];

enum Deontic:
	MUST='must' | MAY='may' | MUST_NOT= 'must_not';

DeonticAction:
	deontic=Deontic action=[Action|ID]'(' (args+=Attribute (',' args+=Attribute)*)? ')';

Reparation:
	'otherwise' referTo=[Clause|ID];

TemporalConstraint:
	'due' constraint=TimeConstraint;

TimeConstraint:
	OpenTimeConstraint | => ClosedTimeConstraint;

OpenTimeConstraint:
	precedence=TemporalPrecedence reference=TimeQuery;

ClosedTimeConstraint:
	closed?='within'? timeframe=TimeFrame precedence=TemporalPrecedence reference=TimeQuery;

enum TemporalPrecedence:
	BEFORE='before' | AFTER='after';

TimeFrame:
	{TimeFrame} (weeks=INT 'weeks')? (days=INT 'days')? (hours=INT 'hours')? (minutes=INT 'minutes')? (seconds=INT 'seconds')?;
	
TimeQuery:
	AbstractTimeQuery | GlobalTimeQuery;

AbstractTimeQuery:
	reference=[TimeQuerySource|FQN];
	
TimeQuerySource:
	Action | Attribute | Clause | Event;

GlobalTimeQuery:
	reference=GlobalTime;

enum GlobalTime:
	NOW='now' | CONTRACT_START='contractStart';
	
Expression:
	Assignment;

Assignment returns Expression:
	Conditional ({Assignment.left=current} '=' right=Conditional)*;

Conditional returns Expression:
	Or ({Conditional.left=current} '?' trueCase=Or ':' falseCase=Or)? |
	'if' Or ({Conditional.left=current} 'then' trueCase=Or 'else' falseCase=Or)? ;
	
Or returns Expression:
	And ({Or.left=current} op=('||' | 'or') right=And)*;

And returns Expression:
	Equality ({And.left=current} op=('&&' | 'and') right=Equality)*;

Equality returns Expression:
	Relation ({Equality.left=current} op=('==' | '!=') right=Relation)*;

Relation returns Expression:
	PlusOrMinus ({Relation.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*;

PlusOrMinus returns Expression:
	MulOrDiv ({PlusOrMinus.left=current} op=('+' | '-') right=MulOrDiv)*;

MulOrDiv returns Expression:
	Unary ({MulOrDiv.left=current} op=('*' | '/') right=Unary)*;

Unary returns Expression:
	Postfix | {Unary} op=('+' | '-') right=Postfix;

Postfix returns Expression:
	Primary ({Postfix.left=current} op=('++'|'--'))*;
	
Primary returns Expression:
	'(' Expression ')' | {Not} op=('!' | 'not') expression=Primary | Atomic;

Atomic returns Expression:
	{IntegerConstant} value=INT | {StringConstant} value=STRING | {BooleanConstant} value=('true' | 'false') | {Reference} value=[ReferenceSource|FQN];

ReferenceSource:
	Attribute | Clause | DotExpression;
 
FQN:
	ID ('.' ID)*;

//terminal BOOL returns ecore::EBoolean:
//	'true' | 'false';

//terminal NUMBER returns ecore::EBigDecimal:
//	/*("-")?*/ ('0'..'9')* ('.' ('0'..'9')+)?;

DotExpression returns Ref:
    DotExpressionStart ({DotExpression.ref=current} ":" tail=[Attribute])*;
 
DotExpressionStart returns Ref:
    {DotExpressionStart} ref=[Entity];

//PathExpression: entity=[Entity] ( '/' pathElements+=[Feature] )+;

@Override 
terminal SL_COMMENT:
	'#' !('\n' | '\r')* ('\r'? '\n')?;

// The following synthetic tokens are used for the indentation-aware blocks
terminal BEGIN: 'synthetic:BEGIN';  // increase indentation
terminal END: 'synthetic:END';      // decrease indentation
