grammar at.ac.univie.swa.Cml with org.eclipse.xtext.common.Terminals

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

generate cml 'http://swa.univie.ac.at/Cml'

Model:
	('namespace' name=FQN)?
	//imports+=Import*
	contracts+=Contract*;

//Import:
//	'import' importedNamespace = QualifiedNameWithWildcard
//  'import' importURI=STRING;
	
Contract:
	'contract' name=ID
	BEGIN
		(attributes+=Attribute |
		 types+=Type |
		 clauses+=Clause |
		 vars+=VariableDeclaration |
		 expr+=Expr)*
	END;
	
Expr:
	'exp' exp=Expression;
	
Feature:
	Attribute | Operation;
	
Operation:
	visibility=Visibility? name=ID '(' (args+=Parameter (',' args+=Parameter)*)? ')' (':' type=ReturnType)?;

Parameter:
	typeDef=AttributeType name=ID;
	
ReturnType:
	{VoidType} 'void' | AttributeType;

VariableDeclaration:
	'var' name=ID ':' typeDef=AttributeType;

AttributeType:
	(collection = Collection)? type=TypeReference (array ?='[' (length=INT)? ']')?;

enum Visibility:
	PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';

Type:
	Class | Enumeration;

TypeReference:
	kind = PrimitiveType | ref = [Type|FQN];

PrimitiveType:
	{IntegerType} 'Integer' | {BooleanType} 'Boolean' | {StringType} 'String' | {DateTimeType} 'DateTime' | {RealType} 'Real' /* | ref=[Entity|ID]*/;

//Entity:
//	Party | Asset | Event;
/*
Type:
	PrimitiveType | ComplexTypeRef;
	
PrimitiveType:
	{IntegerType} 'Integer' | {BooleanType} 'Boolean' | {StringType} 'String' | {DateTimeType} 'DateTime' | {RealType} 'Real';

ComplexTypeRef:
	Class | Party | Asset | Enumeration | Event;
		
ComplexType:
	ref=[ComplexTypeRef];
*/
Attribute:
	name=ID ':' typeDef=AttributeType;

Collection:
	{Set} 'set' | {Bag} 'bag' | {Sequence} 'seq' | {OrderedSet} 'oset';
/* 
IndividualAttribute:
	name=ID ':' typeDef=Type ('=' expr=Expression)?;
	
ArrayAttribute:
	name=ID ':' type=Type '[' (length=INT)? ']';

CollectionAttribute:
	name=ID ':' collection=Collection type=Type;

Attribute:
	IndividualAttribute | CollectionAttribute | ArrayAttribute;
*/

Class:
	(isAbstract?='abstract')? 'class' name=ID ('extends' superClass=[Class|FQN])?
	BEGIN
		features+=Feature*
		exp+=Expr*
	END;

Party:
	'party' name=ID ('identified' 'by' id=[Attribute])? ('extends' superClass=[Party|ID])? 
	BEGIN
		 features+=Feature*
	END;
	
Asset:
	'asset' name=ID ('identified' 'by' id=[Attribute])? ('extends' superClass=[Asset|ID])? 
	BEGIN
		attributes+=Attribute+
	END;

Event:
	'event' name=ID 
	(BEGIN
		attributes+=Attribute
	END)?;
	
Enumeration:
	'enum' name=ID
	BEGIN
		elements+=EnumerationElement*
	END;

EnumerationElement:
	name = ID;
		
Clause:
	'clause' name=ID
	BEGIN
		antecedent=Antecedent
		actor=Actor
		action=DeonticAction
	END;

Antecedent:
	{Antecedent} temporal=TemporalConstraint? general=Constraint?;

TemporalConstraint:
	'due' constraint=TimeConstraint;
	
Constraint:
	'given' expression=Expression;

Actor:
	'party' party=[Attribute];

enum Deontic:
	MUST='must' | MAY='may' | MUST_NOT= 'must_not';

DeonticAction:
	deontic=Deontic compoundAction=AtomicAction;

CompoundAction:
	OrCompoundAction;

OrCompoundAction returns CompoundAction:
	SeqCompoundAction ({OrCompoundAction.left=current} op=('or') right=SeqCompoundAction)*;

SeqCompoundAction returns CompoundAction:
	AndCompoundAction ({SeqCompoundAction.left=current} op=('then') right=AndCompoundAction)*;
	
AndCompoundAction returns CompoundAction:
	AtomicCompoundAction ({AndCompoundAction.left=current} op=('and') right=AtomicCompoundAction)*;

AtomicCompoundAction returns CompoundAction:
	'(' CompoundAction ')' | AtomicAction;

AtomicAction:
	action=[Operation] '(' (args+=[Attribute] (',' args+=[Attribute])*)? ')'
	(BEGIN
		'pre' preCondition=Expression
		('post' postCondition=Expression)?
	END)?;

TimeConstraint:
	closed?='within'? timeframe=(RelativeTime)? period=PeriodicTime? precedence=TemporalPrecedence reference=(AbsoluteTime);

PeriodicTime:
	'every' period=(RelativeTime) 'from' start=(AbsoluteTime) ('until' end=(AbsoluteTime))?;
	
enum TemporalPrecedence:
	BEFORE='before' |
	//BEFORE_OR_EQUALS='before or at the same time as' |
	//EQUALS ='at the same time as' |
	//AFTER_OR_EQUALS='after or at the same time as' |
	AFTER='after';

ClauseQuery:
	'clause' ref=[Clause] 'fulfilled';

EventQuery:
	'event' ref=[Attribute] 'occurred';
	
ActionQuery:
	multiplicity=('all'|'any'|'this')?  partyRef=[Attribute] query='executed' actionRef=[Operation];
	
TimeQuery:
	ClauseQuery | EventQuery | ActionQuery;
	
Time:
	AbsoluteTime | RelativeTime;

AbsoluteTime:
	TimeQuery | globalTimeRef=GlobalTimeReference;
	
RelativeTime:
	TimeFrame;

enum GlobalTimeReference:
	NOW='_now' | CONTRACT_START='_contractStart' | CONTRACT_END='_contractEnd';
	
TimeFrame:
	{TimeFrame} (weeks=INT 'weeks') | {TimeFrame} (days=INT 'days') | {TimeFrame} (hours=INT 'hours') | {TimeFrame} (minutes=INT 'minutes') | {TimeFrame} (seconds=INT 'seconds');
	
Expression: ImpliesExpression;
	
ImpliesExpression returns Expression:
	XorExpression (=>({ImpliesExpression.left=current} op='implies') right=XorExpression)*;

XorExpression returns Expression:
	OrExpression (=>({XorExpression.left=current} op='xor') right=OrExpression)*;

OrExpression returns Expression:
	AndExpression (=>({OrExpression.left=current} op='or') right=AndExpression)*;

AndExpression returns Expression:
	EqualityExpression (=>({AndExpression.left=current} op='and') right=EqualityExpression)*;

EqualityExpression returns Expression :
	RelationalExpression (=>({EqualityExpression.left=current} op=('=='|'!=')) right=RelationalExpression)*;

RelationalExpression returns Expression:
	AdditiveExpression (=>({RelationalExpression.left=current} op=('>' | '<' | '>=' | '<=')) right=AdditiveExpression)*;

//ConditionalOpExp returns Expression:
//	AdditionOpExp ('if' {ConditionalOpExp.left=current} 'then' trueCase=AdditionOpExp 'else' falseCase=AdditionOpExp)? ;

AdditiveExpression returns Expression: 
	MultiplicativeExpression (=>({AdditiveExpression.left=current} op=('+' | '-')) right=MultiplicativeExpression)*;

MultiplicativeExpression returns Expression : 
	UnaryExpression (=>({MultiplicativeExpression.left=current} op=('*' | '/')) right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} op=('not' | '!' | '-' | '+') operand=UnaryExpression | SelectionExpression;

SelectionExpression returns Expression:
	PrimaryExpression 
	(=>({MemberSelection.receiver=current} '.') member=[Feature]
	(=>methodinvocation ?= '(' (args += Expression (',' args += Expression)* )?  ')' )?
	|=>({MemberSelection.receiver=current} isCollectionOperation?='->') coll=CollectionOperation
	(=>methodinvocation ?= '(' (args += Expression (',' args += Expression)* )?  ')' )?)*;

CollectionOperation:
	{SizeCollectionFeature}    'size'       |
	{IsEmptyCollectionFeature} 'isEmpty'    |
	{AtCollectionFeature}      'at'       
;

PrimaryExpression returns Expression:
	ParenthesizedExpression |
	SelfExpression          |
	SuperExpression         |
	LocalReference          |
	LiteralExpression       
;

SelfExpression:
	{SelfExpression} 'self'
;	

SuperExpression:
	{SuperExpression} 'super'
;	

LocalReference:
	ref=[Local]
;

Local:
	VariableDeclaration | Parameter;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

LiteralExpression returns Expression:
	{IntegerLiteral} value=INT |
	{StringLiteral} value=STRING |
	{NullLiteral} 'null' |
	{EnumerationLiteral} enumeration=[Enumeration|FQN] '::' literal=[EnumerationLiteral] |
	{BooleanLiteral} ('false' | 'true');
	
IterativeOperationID returns ecore::EString :
	'exists' | 'forAll'	| 'isUnique' | 'any' | 'one' | 'collect' | 'select'	| 'reject';

CollectionOperationID returns ecore::EString :
	'size'	| 'includes' | 'excludes' | 'count' | 'includesAll' | 'excludesAll' | 'isEmpty' | 'notEmpty' | 'sum';
	
FQN:
	ID ('.' ID)*;
	
terminal BEGIN: 'synthetic:BEGIN';  // increase indentation
terminal END: 'synthetic:END';      // decrease indentation