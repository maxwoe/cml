/*
 * generated by Xtext 2.16.0
 */
package at.ac.univie.swa.generator

import at.ac.univie.swa.CmlLib
import at.ac.univie.swa.CmlModelUtil
import at.ac.univie.swa.cml.AdditiveExpression
import at.ac.univie.swa.cml.AndCompoundAction
import at.ac.univie.swa.cml.AndExpression
import at.ac.univie.swa.cml.Antecedent
import at.ac.univie.swa.cml.AssignmentExpression
import at.ac.univie.swa.cml.AtomicAction
import at.ac.univie.swa.cml.Attribute
import at.ac.univie.swa.cml.Block
import at.ac.univie.swa.cml.BooleanLiteral
import at.ac.univie.swa.cml.CallerExpression
import at.ac.univie.swa.cml.Class
import at.ac.univie.swa.cml.Clause
import at.ac.univie.swa.cml.CmlProgram
import at.ac.univie.swa.cml.CompoundAction
import at.ac.univie.swa.cml.DateTimeLiteral
import at.ac.univie.swa.cml.DurationLiteral
import at.ac.univie.swa.cml.EnsureStatement
import at.ac.univie.swa.cml.EqualityExpression
import at.ac.univie.swa.cml.Expression
import at.ac.univie.swa.cml.FeatureSelection
import at.ac.univie.swa.cml.IfStatement
import at.ac.univie.swa.cml.Import
import at.ac.univie.swa.cml.IntegerLiteral
import at.ac.univie.swa.cml.MultiplicativeExpression
import at.ac.univie.swa.cml.NestedCompoundAction
import at.ac.univie.swa.cml.NestedExpression
import at.ac.univie.swa.cml.Operation
import at.ac.univie.swa.cml.OrCompoundAction
import at.ac.univie.swa.cml.OrExpression
import at.ac.univie.swa.cml.PostfixExpression
import at.ac.univie.swa.cml.RealLiteral
import at.ac.univie.swa.cml.RelationalExpression
import at.ac.univie.swa.cml.ReturnStatement
import at.ac.univie.swa.cml.SeqCompoundAction
import at.ac.univie.swa.cml.Statement
import at.ac.univie.swa.cml.StringLiteral
import at.ac.univie.swa.cml.SymbolReference
import at.ac.univie.swa.cml.ThisExpression
import at.ac.univie.swa.cml.ThrowStatement
import at.ac.univie.swa.cml.TimeConstraint
import at.ac.univie.swa.cml.Type
import at.ac.univie.swa.cml.UnaryExpression
import at.ac.univie.swa.cml.VariableDeclaration
import at.ac.univie.swa.typing.CmlTypeConformance
import com.google.inject.Inject
import java.util.LinkedHashMap
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CmlGenerator extends AbstractGenerator2 {
	
	@Inject extension CmlModelUtil
	@Inject extension CmlTypeConformance
	Iterable<CmlProgram> allResources;
	
	override doGenerate(Resource resource, ResourceSet input, IFileSystemAccess2 fsa, IGeneratorContext context) {
		allResources = input.resources.map(r|r.allContents.toIterable.filter(CmlProgram)).flatten
		for (p : resource.allContents.toIterable.filter(CmlProgram)) {
			if(!p.contracts.empty)	
            	fsa.generateFile(resource.URI.trimFileExtension.toPlatformString(true) + ".sol", p.compile)         
        }
	}
 
 	def comment() {
 		return "// Enums\n"
 	}
    def compile(CmlProgram program) '''
	pragma solidity >=0.4.22 <0.7.0;
	
	«FOR contract : program.contracts»
	contract «contract.name» {

		/*
		 *  Enums
		 */
		«FOR e : program.enums + program.gatherImportedEnums»
			«e.compileEnum»
		«ENDFOR»
		
		/*
		 *  Structs
		 */ 
		«FOR p : #[program] + program.gatherImportedResources»
			«p.compileModel»
		«ENDFOR»
		
		/*
		 *  State variables
		 */
		«FOR a : contract.attributes»
		   	«a.compile»;
		«ENDFOR»
		address _owner;
		uint _creationTime;
		«FOR e : program.events + program.gatherImportedEvents»
			bool _«e.name.toFirstLower»Occured;
		«ENDFOR»
		mapping(bytes4 => bool) _callSuccessMonitor;
		 	
		/*
	 	 *  Events
	 	 */
		«FOR e : program.events + program.gatherImportedEvents»
			«e.compileEvent»
		«ENDFOR»
				
		/*
		 *  Constructor
		 */
		constructor(«FOR a : program.compileConstructorArgs SEPARATOR ', '»«a.key»«a.value»«ENDFOR») public {
			_owner = msg.sender;
			«FOR a : program.compileConstructorAttributes»
				«a.key»= _«a.value»;
			«ENDFOR»
			_creationTime = now;
		}
		
		/*
		 *  Functions
		 */
	 	«FOR clause : contract.clauses»
	 		«clause.action.compoundAction.compile»
		«ENDFOR»
		«FOR e : program.events + program.gatherImportedEvents»
			«e.compileEventAsFunction»
		«ENDFOR»
		// Access control
		function changeOwner(address newOwner) public onlyBy(owner) {
			_owner = newOwner;
		}
		
		// State machine
		function nextStage() internal {
	        stage = Stages(uint(stage) + 1);
	    }
			    
		// Fallback function
		function() external payable {}
		
		/* 	 
		 *  Modifiers
	 	 */
«««		«FOR clause : contract.clauses»
«««			«clause.antecedent.compile»
«««		«ENDFOR»
		// Access control
		modifier onlyBy(address account) { 
			require(msg.sender == account, "Sender not authorized."); _;
		}
		
		// Temporal control
		modifier onlyAfter(uint time, uint duration, bool within) {
			if(!within)
				require(now > time + duration, "Function called too early.");
			else require(time + duration > now && now > time, "Function not called within expected timeframe."); _;
		}
		
		modifier onlyBefore(uint time, uint duration, bool within) {
			if(!within)
				require(now < time - duration, "Function called too late.");
			else require(time - duration < now && now < time, "Function not called within expected timeframe."); _;
		}
		
		// Call control
		modifier postCall(bytes4 selector) {
		    _callSuccessMonitor[selector] = true;
		}
		
		// State machine
		modifier atStage(Stages _stage) {
	        require(stage == _stage, "Function cannot be called at this time."); _;
	    }
	    
	}
	«ENDFOR»
    '''
    
    def retrieveImport(Iterable<CmlProgram> resources, Import i) {
 		if(i.importedNamespace !== CmlLib::LIB_PACKAGE)
 			resources.findFirst[name == i.copy.importedNamespace.replace(".*","")]
 	}
 	
 	def gatherImportedEvents(CmlProgram program) {
 		program.gatherImportedResources.map[events].flatten
 	}
 	
 	def gatherImportedEnums(CmlProgram program) {
 		program.gatherImportedResources.map[enums].flatten
 	}
 	
 	def gatherImportedResources(CmlProgram program) {
 		var list = newArrayList
 		for(import : program.imports) {
 			list += this.allResources.retrieveImport(import)
 		}
 		list
 	}
 	
    def List<Pair<String, String>> compileConstructorArgs(CmlProgram p) {
    	// TODO
    	emptyList
    }
    
    def List<Pair<String, String>> compileConstructorAttributes(CmlProgram p) {
    	// TODO
    	emptyList
    }
    
    def String compile(CompoundAction ca) {
		switch (ca) {
			OrCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				//left + " || " + right
				left + right
			}
			SeqCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				//left + " then " + right
				left + right
			}
			AndCompoundAction: {
				val left = ca.left.compile
				val right = ca.right.compile
				//left + " && " + right
				left + right
			}
			NestedCompoundAction: {
				ca.child.compile
				//val child = ca.child.compile				
				//"(" + child + ")" 
			}
		 	AtomicAction: ca.reference.compile(ca.containingClause).toString
		}
	}
    
    def compile(List<Attribute> attributes) '''
    	«FOR a : attributes SEPARATOR ', '»«a.compile»«ENDFOR»'''
    
    def compile(Attribute a) '''
    	«(a.type as Type).compile» « a.name»'''
    
    def compileModel(CmlProgram program) '''
	«FOR c : program.classes»
		«IF !c.isAbstract && (c.subclassOfParty || c.subclassOfAsset)»«c.compile»«ENDIF»
	«ENDFOR»
	'''
	
    def compile(Class c) '''
	struct «c.name.toFirstUpper» {
	   	«FOR f : c.classHierarchyAttributes.values»
	   		«f.compile»;
	   	«ENDFOR»
	   	«FOR f : c.attributes»
	   		«f.compile»;
	   	«ENDFOR»
	}
	''' 
    
    def compile(Operation o, Clause c) '''	
	// @notice function for clause «c.name»
	function «o.name»(«o.params.compile») public «FOR m : o.deriveModifiers(c).entrySet SEPARATOR ' '»«m.key»(«m.value.join(", ")»)«ENDFOR» {
«««		// TODO: Implement code to «o.name» «FOR arg : o.params SEPARATOR ', '»«arg.name»«ENDFOR»
		«FOR s : o.body.statements»
		«compileStatement(s)»
		«ENDFOR»
	}
	
	'''
	
	def deriveModifiers(Operation o, Clause c) {
		var modifiers = new LinkedHashMap<String, List<String>>(); 
		var party = c.actor.party
		var tc = c.antecedent.temporal
		if(party != "anyone")
			modifiers.put("onlyBy", #[party.name])
		if(tc !== null) {
			if(tc.reference instanceof Expression) {
				if(tc.timeframe === null)
					modifiers.put("only" + tc.precedence.literal.toFirstUpper, #[(tc.reference as Expression).compile, "0", "false"])
				if(tc.closed == false && tc.timeframe !== null)
					modifiers.put("only" + tc.precedence.literal.toFirstUpper, #[(tc.reference as Expression).compile, tc.timeframe.compile, "false"])
				if(tc.closed == true && tc.timeframe !== null)
					modifiers.put("only" + tc.precedence.literal.toFirstUpper, #[(tc.reference as Expression).compile, tc.timeframe.compile, "true"])
			}
		}
		modifiers.put("postCall", #["this." + o.name + ".selector"])
		modifiers
	}
	
	def compileBlock(Block block) '''
	{	
		«FOR s : block.statements»
		«s.compileStatement»
		«ENDFOR»
	}
	'''
	
	def String compileStatement(Statement s) {
		switch (s) {
			VariableDeclaration: '''«s.name» = «s.expression.compile»;'''
			ReturnStatement: "return " + s.expression.compile + ";"
			IfStatement: '''
			if («s.condition.compile»)
			«s.thenBlock.compileBlock»
			«IF s.elseBlock !== null»
			else
			«s.elseBlock.compileBlock»
			«ENDIF»
			'''
			EnsureStatement: '''require(«s.expression.compile»«IF s.throwExpression !== null»; «s.throwExpression.compile»«ENDIF»);'''
			ThrowStatement: '''revert(«s.expression?.compile»);'''
			default: (s as Expression).compile + ";"
		}
	}

	def compileEvent(Class c) '''
	event «c.name.toFirstUpper»();'''
	
	def compileEventAsFunction(Class c) '''	
	// @notice trigger event «c.name»
	function «c.name.toFirstLower»() public {
		_«c.name.toFirstLower»Occured = true;
		emit «c.name.toFirstUpper»();
	}
	
	'''
	
	def compileEnum(Class c) '''
	enum «c.name.toFirstUpper» { «FOR e : c.enumElements SEPARATOR ', '»«e.name»«ENDFOR» } «c.name.toFirstUpper» «c.name.toFirstLower»;
	'''
	
    def compile(Type t) {
		switch (t) {
			Class:
				switch (t) {
					case t.conformsToInteger: "uint"
					case t.conformsToBoolean: "bool"
					case t.conformsToString: "bytes32"
					case t.conformsToReal: "uint"
					case t.conformsToDateTime: "uint"
					case t.conformsToDuration: "uint"
					case t.conformsToEnum: t.name
					case t.conformsToSet: "???"
					case t.conformsToMap: "mapping( ? => ? )"
					case t.conformsToAsset: t.name
					case t.conformsToParty: "address"
					default: t.name
				}
		}
	}
	
	def compile(Antecedent a, Clause c) '''
	// @notice modifier for clause «c.name»
	modifier guard() {
		«IF a.temporal !== null»require(«a.temporal.compile»)«ENDIF»;
		require(«a.general.expression.compile»); _;
	}
	
	'''
	
	def compileModifier(Expression e) '''
	// @notice modifier for function «e.containingOperation.name»
	modifier guard_«e.containingOperation.name»() {
		require(«e.compile»); _;
	}
	
	'''
	
	def compile(TimeConstraint tc) {
		var modifiers = new LinkedHashMap<String, List<String>>(); 
		if(tc.closed == false && tc.timeframe === null) {
			if(tc.precedence == "after" && tc.reference instanceof Expression)
				modifiers.put("onlyAfter", #[(tc.reference as Expression).compile, "0"])
			if(tc.precedence == "before" && tc.reference instanceof Expression)
				modifiers.put("onlyBefore", #[(tc.reference as Expression).compile, "0"])
		}
	}
	
	def String compile(Expression exp) {
		
		switch (exp) {
			
			AssignmentExpression: 
				'''«(exp.left.compile)» = «(exp.right.compile)»'''
			OrExpression: 
				'''«(exp.left.compile)» || «(exp.right.compile)»'''
			
			AndExpression: 
				'''«(exp.left.compile)» && «(exp.right.compile)»'''
			
			EqualityExpression: {
				if (exp.op == '==')
					'''«(exp.left.compile)» == «(exp.right.compile)»'''
				else
					'''«(exp.left.compile)» != «(exp.right.compile)»'''
			}
			RelationalExpression: {
				val left = exp.left.compile
				val right = exp.right.compile

				switch (exp.op) {
					case '<': '''«left» < «right»'''
					case '>': '''«left» > «right»'''
					case '>=': '''«left» >= «right»'''
					case '<=': '''«left» <= «right»'''
					default:
						""
				}
			}
			AdditiveExpression: {
				if (exp.op == '+')
					'''«(exp.left.compile)» + «(exp.right.compile)»'''
				else
					'''«(exp.left.compile)» - «(exp.right.compile)»'''
			}
			MultiplicativeExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				if (exp.op == '*')
					'''«left» * «right»''' 
				else
					'''«left» / «right»'''
			}
			UnaryExpression: {
				switch (exp.op) {
					case '+': ''' +«(exp.operand.compile)»'''
					case '-': ''' -«(exp.operand.compile)»'''
					case '!',
					case 'not': ''' !«(exp.operand.compile)»'''
					default:
						""
				}				
			}
			PostfixExpression: {
				if (exp.op == '++')
					'''«(exp.operand.compile)»++'''
				else
					'''«(exp.operand.compile)»--'''
			}
			NestedExpression: '''(«exp.child.compile»)'''
			RealLiteral: '''«exp.value»'''
			IntegerLiteral: '''«exp.value»'''
			BooleanLiteral: '''«exp.value»'''
			StringLiteral: '''"«exp.value»"'''
			ThisExpression: '''this'''
			DateTimeLiteral: '''«exp.value»'''
			DurationLiteral: '''«exp.value» «exp.unit»'''
			CallerExpression: '''msg.sender'''
			SymbolReference: '''«exp.compile»'''
			FeatureSelection: exp.featureSelectionTransformation
		}
	}
	
	def featureSelectionTransformation(FeatureSelection fs) {
		var String rslt
		if (fs.opCall && fs.feature instanceof Operation)
			rslt = interceptOperation(fs.feature as Operation, fs.args, fs.receiver)

		if (rslt === null) {
			rslt = fs.receiver.compile + "." + fs.feature.name + if (fs.opCall) {
				"(" + fs.args.map[compile].join(", ") + ")"
			} else
				""
		}
		rslt
	}
	
	def compile(SymbolReference sr) {
		if (sr.opCall && sr.symbol instanceof Operation) {
			interceptOperation(sr.symbol as Operation, sr.args, null)
		} else sr.symbol.name
	}
	
	def interceptOperation(Operation o, List<Expression> args, Expression receiver) {
		var c = o.containingClass
		switch (c) {
			case c.conformsToDateTime: {
				switch (o.name) {
					case "addDuration": receiver.compile + " + " + args.get(0).compile
				}
			}
			case c.conformsToInteger: {
				switch (o.name) {
					case "toReal": "IntLib.toReal(" + receiver.compile +")"
				}
			}
			case c.conformsToReal: {
				switch (o.name) {
					case "toInteger": "RealLib.toReal(" + receiver.compile +")"
				}
			}
			case c.conformsToContract: {
				switch (o.name) {
					case "failure": args.get(0).compile
				}
			}
		}
	}
	
	def <T> index(Iterable<T> i) {
		val Map<Integer, T> map = <Integer, T>newHashMap()
		var counter = 0
		for (T e : i) {
			map.put(counter, e)
			counter = counter++
		}
		val Set<Map.Entry<Integer, T>> res = map.entrySet
		res
	}

}

