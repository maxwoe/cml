/*
 * generated by Xtext 2.16.0
 */
package at.ac.univie.swa.generator

import at.ac.univie.swa.CmlLib
import at.ac.univie.swa.CmlModelUtil
import at.ac.univie.swa.cml.AdditiveExpression
import at.ac.univie.swa.cml.AndCompoundAction
import at.ac.univie.swa.cml.AndExpression
import at.ac.univie.swa.cml.Antecedent
import at.ac.univie.swa.cml.AssignmentExpression
import at.ac.univie.swa.cml.Attribute
import at.ac.univie.swa.cml.Block
import at.ac.univie.swa.cml.BooleanLiteral
import at.ac.univie.swa.cml.CallerExpression
import at.ac.univie.swa.cml.Class
import at.ac.univie.swa.cml.Clause
import at.ac.univie.swa.cml.CmlProgram
import at.ac.univie.swa.cml.CompoundAction
import at.ac.univie.swa.cml.DateTimeLiteral
import at.ac.univie.swa.cml.DurationLiteral
import at.ac.univie.swa.cml.EnsureStatement
import at.ac.univie.swa.cml.EqualityExpression
import at.ac.univie.swa.cml.Expression
import at.ac.univie.swa.cml.IfStatement
import at.ac.univie.swa.cml.Import
import at.ac.univie.swa.cml.IntegerLiteral
import at.ac.univie.swa.cml.MemberSelection
import at.ac.univie.swa.cml.MultiplicativeExpression
import at.ac.univie.swa.cml.Operation
import at.ac.univie.swa.cml.OrCompoundAction
import at.ac.univie.swa.cml.OrExpression
import at.ac.univie.swa.cml.PostfixExpression
import at.ac.univie.swa.cml.RealLiteral
import at.ac.univie.swa.cml.RelationalExpression
import at.ac.univie.swa.cml.ReturnStatement
import at.ac.univie.swa.cml.SeqCompoundAction
import at.ac.univie.swa.cml.Statement
import at.ac.univie.swa.cml.StringLiteral
import at.ac.univie.swa.cml.SymbolReference
import at.ac.univie.swa.cml.ThisExpression
import at.ac.univie.swa.cml.ThrowStatement
import at.ac.univie.swa.cml.TimeConstraint
import at.ac.univie.swa.cml.Type
import at.ac.univie.swa.cml.UnaryExpression
import at.ac.univie.swa.cml.VariableDeclaration
import at.ac.univie.swa.typing.CmlTypeConformance
import at.ac.univie.swa.typing.CmlTypeProvider
import com.google.inject.Inject
import java.util.LinkedHashMap
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CmlGenerator extends AbstractGenerator2 {
	
	@Inject extension CmlModelUtil
	@Inject extension CmlLib
	@Inject extension CmlTypeProvider
	@Inject extension CmlTypeConformance
	Iterable<CmlProgram> allResources;
	
	override doGenerate(Resource resource, ResourceSet input, IFileSystemAccess2 fsa, IGeneratorContext context) {
		allResources = input.resources.map(r|r.allContents.toIterable.filter(CmlProgram)).flatten
		for (p : resource.allContents.toIterable.filter(CmlProgram)) {
			if(!p.contracts.empty)	
            	fsa.generateFile(resource.URI.trimFileExtension.toPlatformString(true) + ".sol", p.compile)         
        }
	}
 
 	def retrieveImport(Iterable<CmlProgram> resources, Import i) {
 		if(i.importedNamespace !== CmlLib::LIB_PACKAGE)
 			resources.findFirst[name == i.copy.importedNamespace.replace(".*","")]
 	}
 	
 	def gatherImportedEvents(CmlProgram program) {
 		program.retrieveImportedResources.map[events].flatten
 	}
 	
 	def gatherImportedEnums(CmlProgram program) {
 		program.retrieveImportedResources.map[enums].flatten
 	}
 	
 	def retrieveImportedResources(CmlProgram program) {
 		var list = newArrayList
 		for(import : program.imports) {
 			list += this.allResources.retrieveImport(import)
 		}
 		list
 	}
 	
    def compile(CmlProgram program) '''
	pragma solidity >=0.4.22 <0.7.0;
	
	«FOR contract : program.contracts»
	contract «contract.name» {
		
		/*
		 *  Enums
		 */
		«FOR e : program.enums + program.gatherImportedEnums»
			«e.compileEnum»
		«ENDFOR»
		
		/*
		 *  Structs
		 */
		«program.compileModel»
		«FOR p : program.retrieveImportedResources»
			«p.compileModel»
		«ENDFOR»	
		/*
		 *  State variables
		 */	
		address owner;
		uint creationTime;
		«FOR a : contract.attributes»
		   	«a.compile»;
		«ENDFOR»
		«FOR e : program.events + program.gatherImportedEvents»
			bool «e.name.toFirstLower»Occured;
		«ENDFOR»
		
		/*
	 	 *  Events
	 	 */
		«FOR e : program.events + program.gatherImportedEvents»
			«e.compileEvent»
		«ENDFOR»
		
		/*
		 *  Constructor
		 */
		constructor(«FOR a : program.compileConstructorArgs SEPARATOR ', '»«a.key»«a.value»«ENDFOR») public {
			owner = msg.sender;
			«FOR a : program.compileConstructorAttributes»
				«a.key»= _«a.value»;
			«ENDFOR»
			creationTime = now;
		}
		
		/*
		 *  Functions
		 */
	 	«FOR clause : contract.clauses»
	 		«clause.action.compoundAction.compile»
		«ENDFOR»
		«FOR e : program.events + program.gatherImportedEvents»
			«e.compileEventAsFunction»
		«ENDFOR»
		function changeOwner(address _newOwner) public onlyBy(owner) {
			owner = _newOwner;
		}
		
		// Fallback function
		function() external payable {}
		
		/* 	 
		 *  Modifiers
	 	 */
«««		«FOR clause : contract.clauses»
«««			«clause.antecedent.compile»
«««		«ENDFOR»
		modifier onlyBy(address _account) { 
			require(msg.sender == _account, "Sender not authorized."); _;
		}
		
		modifier onlyAfter(uint _time, uint _duration, bool _within) {
			if(!_within)
				require(now > _time + _duration, "Function called too early.");
			else require(_time + _duration > now && now > _time, "Function not called within expected timeframe."); _;
		}
		
		modifier onlyBefore(uint _time, uint _duration, bool _within) {
			if(!_within)
				require(now < _time - _duration, "Function called too late.");
			else require(_time - _duration < now && now < _time, "Function not called within expected timeframe."); _;
		}
	}
	«ENDFOR»
    '''
    
    def List<Pair<String, String>> compileConstructorArgs(CmlProgram p) {
    	// TODO
    	emptyList
    }
    
    def List<Pair<String, String>> compileConstructorAttributes(CmlProgram p) {
    	// TODO
    	emptyList
    }
    
    def compile(CompoundAction ca) {
    	switch(ca) {
    		OrCompoundAction,
			SeqCompoundAction,
			AndCompoundAction: {ca.left.compile ca.right.compile}
			CompoundAction: ca.reference.compile(ca.containingClause)
    	}	
    } 	
    
    def compile(List<Attribute> attributes) '''
    	«FOR a : attributes SEPARATOR ', '»«a.compile»«ENDFOR»'''
    
    def compile(Attribute a) '''
    	«(a.type as Type).compile» « a.name»'''
    
    def compileModel(CmlProgram program) '''
	«FOR c : program.classes»
		«IF !c.isAbstract && (c.subclassOfParty || c.subclassOfAsset)»«c.compile»«ENDIF»
	«ENDFOR»
	'''
	
    def compile(Class c) '''
	struct «c.name.toFirstUpper» {
	   	«FOR f : c.classHierarchyAttributes.values»
	   		«f.compile»;
	   	«ENDFOR»
	   	«FOR f : c.attributes»
	   		«f.compile»;
	   	«ENDFOR»
	}
	
   ''' 
    
    def compile(Operation o, Clause c) '''	
	// @notice function for clause «c.name»
	function «o.name»(«o.params.compile») public «FOR m : o.deriveModifiers(c).entrySet SEPARATOR ' '»«m.key»(«m.value.join(", ")»)«ENDFOR» {
«««		// TODO: Implement code to «o.name» «FOR arg : o.params SEPARATOR ', '»«arg.name»«ENDFOR»
		«FOR s : o.body.statements»
		«compileStatement(s)»
		«ENDFOR»
	}
	
	'''
	
	def deriveModifiers(Operation o, Clause c) {
		var modifiers = new LinkedHashMap<String, List<String>>(); 
		var party = c.actor.party
		var tc = c.antecedent.temporal
		if(party != "anyone")
			modifiers.put("onlyBy", #[party.name])
		if(tc !== null) {
			if(tc.reference instanceof Expression) {
				if(tc.timeframe === null)
					modifiers.put("only" + tc.precedence.literal.toFirstUpper, #[(tc.reference as Expression).compile, "0", "false"])
				if(tc.closed == false && tc.timeframe !== null)
					modifiers.put("only" + tc.precedence.literal.toFirstUpper, #[(tc.reference as Expression).compile, tc.timeframe.compile, "false"])
				if(tc.closed == true && tc.timeframe !== null)
					modifiers.put("only" + tc.precedence.literal.toFirstUpper, #[(tc.reference as Expression).compile, tc.timeframe.compile, "true"])
			}
		}
		modifiers
	}
	
	def compileBlock(Block block) '''
	{	
		«FOR s : block.statements»
		«s.compileStatement»
		«ENDFOR»
	}
	'''
	
	def String compileStatement(Statement s) {
		switch (s) {
			VariableDeclaration: '''«s.name» = «s.expression.compile»;'''
			ReturnStatement: "return " + s.expression.compile + ";"
			IfStatement: '''
			if («s.condition.compile»)
			«s.thenBlock.compileBlock»
			«IF s.elseBlock !== null»
			else
			«s.elseBlock.compileBlock»
			«ENDIF»
			'''
			EnsureStatement: '''require(«s.expression.compile»«IF s.throwExpression !== null»; «s.throwExpression.compile»«ENDIF»);'''
			ThrowStatement: '''revert(«s.expression?.compile»);'''
			default: (s as Expression).compile + ";"
		}
	}

	def compileEvent(Class c) '''
	event «c.name.toFirstUpper»();'''
	
	def compileEventAsFunction(Class c) '''	
	// @notice trigger event «c.name»
	function «c.name.toFirstLower»() public {
		«c.name.toFirstLower»Occured = true;
		emit «c.name.toFirstUpper»();
	}
	
	'''
	
	def compileEnum(Class c) '''
	enum «c.name.toFirstUpper» { «FOR e : c.enumElements SEPARATOR ', '»«e.name»«ENDFOR» }
	«c.name.toFirstUpper» «c.name.toFirstLower»;'''
	
    def compile(Type t) {
		switch (t) {
			Class:
				switch (t) {
					case t.conformsToInteger: "uint"
					case t.conformsToBoolean: "bool"
					case t.conformsToString: "bytes32"
					case t.conformsToReal: "uint"
					case t.conformsToDateTime: "uint"
					case t.conformsToDuration: "uint"
					case t.conformsToEnum: t.name
					case t.conformsToSet: "???"
					case t.conformsToMap: "mapping( ? => ? )"
					case t.conformsToAsset: t.name
					case t.conformsToParty: "address"
					default: t.name
				}
		}
	}
	
	def compile(Antecedent a, Clause c) '''
	// @notice modifier for clause «c.name»
	modifier guard() {
		«IF a.temporal !== null»require(«a.temporal.compile»)«ENDIF»;
		require(«a.general.expression.compile»); _;
	}
	
	'''
	
	def compileModifier(Expression e) '''
	// @notice modifier for function «e.containingOperation.name»
	modifier guard_«e.containingOperation.name»() {
		require(«e.compile»); _;
	}
	
	'''
	
	def compile(TimeConstraint tc) {
		var modifiers = new LinkedHashMap<String, List<String>>(); 
		if(tc.closed == false && tc.timeframe === null) {
			if(tc.precedence == "after" && tc.reference instanceof Expression)
				modifiers.put("onlyAfter", #[(tc.reference as Expression).compile, "0"])
			if(tc.precedence == "before" && tc.reference instanceof Expression)
				modifiers.put("onlyBefore", #[(tc.reference as Expression).compile, "0"])
		}
	}
	
	def String compile(Expression exp) {
		
		switch (exp) {
			
			AssignmentExpression: 
				'''«(exp.left.compile)» = «(exp.right.compile)»'''
			OrExpression: {
				'''«(exp.left.compile)» || «(exp.right.compile)»'''
			}
			AndExpression: {
				'''«(exp.left.compile)» && «(exp.right.compile)»'''
			}
			EqualityExpression: {
				if (exp.op == '==')
					'''«(exp.left.compile)» == «(exp.right.compile)»'''
				else
					'''«(exp.left.compile)» != «(exp.right.compile)»'''
			}
			RelationalExpression: {
				val left = exp.left.compile
				val right = exp.right.compile

				switch (exp.op) {
					case '<': '''«left» < «right»'''
					case '>': '''«left» > «right»'''
					case '>=': '''«left» >= «right»'''
					case '<=': '''«left» <= «right»'''
					default:
						""
				}
			}
			AdditiveExpression: {
				if (exp.op == '+')
					'''«(exp.left.compile)» + «(exp.right.compile)»'''
				else
					'''«(exp.left.compile)» - «(exp.right.compile)»'''
			}
			MultiplicativeExpression: {
				val left = exp.left.compile
				val right = exp.right.compile
				if (exp.op == '*')
					'''«left» * «right»''' 
				else
					'''«left» / «right»'''
			}
			UnaryExpression: {
				if (exp.op == '+')
					''' +«(exp.operand.compile)»'''
				else
					''' -«(exp.operand.compile)»'''
			}
			PostfixExpression: {
				if (exp.op == '++')
					'''«(exp.operand.compile)»++'''
				else
					'''«(exp.operand.compile)»--'''
			}
			RealLiteral: '''«exp.value»'''
			IntegerLiteral: '''«exp.value»'''
			BooleanLiteral: '''«exp.value»'''
			StringLiteral: '''"«exp.value»"'''
			ThisExpression: '''this'''
			DateTimeLiteral: '''«exp.value»'''
			DurationLiteral: '''«exp.value» «exp.unit»'''
			CallerExpression: '''msg.sender'''
			SymbolReference: '''«exp.compile»'''
			MemberSelection: exp.memberSelectionTransformation
		}
	}
	
	def memberSelectionTransformation(MemberSelection ms) {
		var String rslt
		if (ms.methodinvocation && ms.member instanceof Operation)
			rslt = interceptOperation(ms.member as Operation, ms.args, ms.receiver)

		if (rslt === null) {
			rslt = ms.receiver.compile + "." + ms.member.name + if (ms.methodinvocation) {
				"(" + ms.args.map[compile].join(", ") + ")"
			} else
				""
		}
		rslt
	}
	
	def compile(SymbolReference sr) {
		if (sr.methodinvocation && sr.symbol instanceof Operation) {
			interceptOperation(sr.symbol as Operation, sr.args, null)
		} else sr.symbol.name
	}
	
	def interceptOperation(Operation o, List<Expression> args, Expression receiver) {
		var c = o.containingClass
		switch (c) {
			case c.conformsToDateTime: {
				switch (o.name) {
					case "addDuration": receiver.compile + " + " + args.get(0).compile
				}
			}
			case c.conformsToInteger: {
				switch (o.name) {
					case "toReal": "IntLib.toReal(" + receiver.compile +")"
				}
			}
			case c.conformsToReal: {
				switch (o.name) {
					case "toInteger": "RealLib.toReal(" + receiver.compile +")"
				}
			}
			case c.conformsToContract: {
				switch (o.name) {
					case "failure": args.get(0).compile
				}
			}
		}
	}

}

